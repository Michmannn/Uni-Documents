\section{Работа с программами}

Программа, оформленная как процедура, к которой обращение происходит из ОС, заканчивается командой возврата ret.

Подпрограмма, как вспомогательный алгоритм, к которому возможно многократное обращение с помощью команды call,
тоже оформляется как процедура с помощью директив proc и endp. Структуру процедуры можно оформить так:

\begin{minted}{asm}
    <имя процедуры> proc <параметр>
        <тело процедуры>
        ret
    <имя процедуры> endp
\end{minted}

В Ассемблере один тип подпрограмм - процедура. Размешать ее можно в любом месте программы, но так, чтобы управление на нее не попадало случайно, а только по команда call.
Поэтому описание ПП принято располагать в конце программного сегмента (после последней исполняемой команды), или вначале его - перед первой исполняемой командой.

\section{Графическое представление}

\begin{minted}{asm}
    1) cseg segment .....
    beg: ----------------
    ---------------------
    ---------------------
    fin: ----------------
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    2) cseg segment
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    beg:-----------------
    ---------------------

    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    3) cseg_pp segment
    <>
    cseg_pp ends
    cseg segment...
    ---------------------
    cseg ends
    end beg
\end{minted}

Если программа содержит большое количество подпрограмм, то ПП размещают в отдельном кодовом сегменте - вариант структуры 3).

\paragraph{Замечания:}

\begin{itemize}
    \item После имени в директивах proc и endp двоеточие не ставится, но имя считается меткой, адресом первой исполняемой процедуры.
    \item Метки, описанные в ПП, не локализируются в ней, поэтому они должны быть уникальными в рамках всей программы.
    \item Параметр в директиве начала процедуры один - FAR или NEAR.
\end{itemize}

Основной проблемой при работе с ПП является передача параметров и возврат результатов в вызывающую программу.
Существуют различные способы передачи параметров:
\begin{enumerate}
    \item по значению;
    \item по ссылке;
    \item по возращаемому значению;
    \item по результату;
    \item отложенным вычислением.
\end{enumerate}

Параметры можно передавать:
\begin{enumerate}
    \item через регистры;
    \item в глобальных переменных;
    \item через стек;
    \item в потоке кода;
    \item в блоке параметров.
\end{enumerate}

Передача параметров через регистры - наиболее простой способ. Вызывающая программа записывает в некоторые регистры фактические парамтеры...

\textbf{Примерами использования этого метода являются вызовы некоторых прерываний ОС и BIOS.}

Когда регистров не хватает, один из способов обойти это ограничение - записать параметр в глобальную переменную, к которой затем обращаться в ПП.
Но этот мето считается не эффективным, так как может оказаться невозможной рекурсия, и даже простое повторное обращение к ПП.

Передача параметров через стек. Перед обращением к процедуре фактические параметры (их значения или адреса) записываются в стек, а процедура их из стека извлекает.
Именно этот способ используют языки высокого уровня.

Передача параметров в потоке кода заключается в том, что данные, передаваемые в ПП, располагаются сразу за командой обращения к ПП call.
ПП, чтобы использовать эти данные, должна обратиться к ним по адресу, который записывается в стек автоматически как адрес возврата из ПП.
Но ПП в этом случае должна перед командой возврата изменить адрес возврата на адрес байта, следующий за передаваемыми параметрами. Этот метод реализует передачу
параметров медленнее, чем через регистры, глобальные переменные или стек, но примерно также, как и метод передачи параметров в блок параметров.

Блок параметров - это участок памяти, содержащий параметры и располагающийся обычно в сегменте данных.

Процедура получает адрес начала этого блока при помощи любого из рассмотренных методов: в регистре, в переменной, в стеке, в коде или даже в другом блоке параметров.
Примеры использования этого способа - многие функции ОС и BIOS, например, поиск файла, использующий блок параметров DTA, или загрущка и исполнение программы, использующая блок параметров EPB.

\subsection{Передача параметров по значению и по ссылке}

При передаче параметров по значению процедуры передается значение фактического параметра, оно копируется в ПП, и ПП использует копию, поэтому изменение, модификация параметра
оказывается невозможным. Этот механизм используется для передачи параметров небольшого размера.

Например, нужно вычислить \textbf{c = max(a, b) + max(7, a-1)}. Здесь все числа знаковые, размером в слово. Используем передачу параметров через регистры. Процедура получает параметры через
регистры. Процедура получает параметры через регистры AX и BX, результат возвращается в регистр AX.
Процедура:
\begin{minted}{asm}
    AX = max(AX, BX)
    max proc
        cmp AX, BX
        jge met1
        mov AX, BX
        met1: ret
    max endp
\end{minted}

\section{Фрагмент вызывающей программы:}
-----------------
\begin{minted}{asm}
    ; c = max(a, b) + max(7, a-1)
    mov AX, a
    mov BX, b
    call max ; AX = max(a, b)
    mov c, AX ; c = max(a, b)
    mov AX, 7
    mov BX, a
    dec BX
    call max ; AX = max(7, a-1)
    add c, AX
\end{minted}
-----------------

\section{Передача параметров по ссылке.}

Оформим как процедуру вычисление \textbf{x = x div 16}

Процедура имеет один параметр-переменную х, которой в теле процедуры присваивается новое значение. Т.е. результат записывается в некоторую ячейку памяти. И чтобы обратиться к процедуре с различными параметрами, например,
a и b, ей нужно передавать адреса памяти, где хранятся значения переменных a и b. Передавать адреса можно любым способом, в том числе и через регистры. Можно использовать различные регистры, но чаще используются BX, BP, SI, DI.
Пусть адрес параметра передается через регистр ВХ, тогда фрагмент программы:
\begin{minted}{asm}
    ; основная программа
    --------------------
    lea RBX, a
    call Proc_div
    lea BX, b
    call Proc_dv
\end{minted}

Процедура:
\begin{minted}{asm}
    Proc_dv proc
        push CX
        mov CL, 4
        shr word ptr [BX], CL ; x = x div 16
        pop CX
        ret
    Proc_dv endp
\end{minted}
Сдвиг на 4 разряда вправо эквивалентен делению нацело на 16 и выполняется быстрее.

Здесь первая команда в процедуре сохраняет в стеке значение регистра СХ, так как затем использует CL в команде сдвига и возможно этот регистр используется в основной программе.

Т.к. регистров немного а и ПП, и основная программа могут использовать одни и те же регистры, то при входе в ПП нужно сохранять в стеке значения регистров, которые будут использоваться в ПП, а перед выходом из нее восстанавливать значениях этих регистров.
Для поддержки  этого, начиная с ix186, в систему команд введены команды сохранения в стеке и извлечения из него сразу всех регистров общего назначения
\textbf{pusha} и \textbf{popa}, а, начиная с ix386, \textbf{pushad popad}.

Не нужно сохранять в стеке значение регистра, в который записывается результат работы ПП.

\section{Передача параметров по ссылке в блоке параметров}

Если параметров много, например, массив, адрес начала массива как блока параметров, можно передать через регистр, даже если результат ПП не будет записываться по этому адресу.

Даны два массива целых положительных чисел без знака
\begin{minted}{asm}
    X db 100 dup (?)
    Y db 50 dup (?)
\end{minted}

Вычислить DL = max(X[i]) + max(Y[i]), использовав процедуру max(A[i]), пересылая адрес массива через регистр ВХ, а результат сохраняя в AL.
\begin{minted}{asm}
    ; фрагмент программы
    lea BX, X
    mov CX, 100
    call max ; AL = max(X[i])
    mov DL, AL ; DL = max(X[i])
    lea BX, Y
    mov CX, 50
    call max
    add DL, AL
\end{minted}