\section{Работа с программами}

Программа, оформленная как процедура, к которой обращение происходит из ОС, заканчивается командой возврата ret.

Подпрограмма, как вспомогательный алгоритм, к которому возможно многократное обращение с помощью команды call,
тоже оформляется как процедура с помощью директив proc и endp. Структуру процедуры можно оформить так:

\begin{minted}{asm}
    <имя процедуры> proc <параметр>
        <тело процедуры>
        ret
    <имя процедуры> endp
\end{minted}

В Ассемблере один тип подпрограмм - процедура. Размешать ее можно в любом месте программы, но так, чтобы управление на нее не попадало случайно, а только по команда call.
Поэтому описание ПП принято располагать в конце программного сегмента (после последней исполняемой команды), или вначале его - перед первой исполняемой командой.

\section{Графическое представление}

\begin{minted}{asm}
    1) cseg segment .....
    beg: ----------------
    ---------------------
    ---------------------
    fin: ----------------
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    2) cseg segment
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    beg:-----------------
    ---------------------

    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    3) cseg_pp segment
    <>
    cseg_pp ends
    cseg segment...
    ---------------------
    cseg ends
    end beg
\end{minted}

Если программа содержит большое количество подпрограмм, то ПП размещают в отдельном кодовом сегменте - вариант структуры 3).

\paragraph{Замечания:}

\begin{itemize}
    \item После имени в директивах proc и endp двоеточие не ставится, но имя считается меткой, адресом первой исполняемой процедуры.
    \item Метки, описанные в ПП, не локализируются в ней, поэтому они должны быть уникальными в рамках всей программы.
    \item Параметр в директиве начала процедуры один - FAR или NEAR.
\end{itemize}

Основной проблемой при работе с ПП является передача параметров и возврат результатов в вызывающую программу.
Существуют различные способы передачи параметров:
\begin{enumerate}
    \item по значению;
    \item по ссылке;
    \item по возращаемому значению;
    \item по результату;
    \item отложенным вычислением.
\end{enumerate}

Параметры можно передавать:
\begin{enumerate}
    \item через регистры;
    \item в глобальных переменных;
    \item через стек;
    \item в потоке кода;
    \item в блоке параметров.
\end{enumerate}

Передача параметров через регистры - наиболее простой способ. Вызывающая программа записывает в некоторые регистры фактические парамтеры...

\textbf{Примерами использования этого метода являются вызовы некоторых прерываний ОС и BIOS.}

Когда регистров не хватает, один из способов обойти это ограничение - записать параметр в глобальную переменную, к которой затем обращаться в ПП.
Но этот мето считается не эффективным, так как может оказаться невозможной рекурсия, и даже простое повторное обращение к ПП.

Передача параметров через стек. Перед обращением к процедуре фактические параметры (их значения или адреса) записываются в стек, а процедура их из стека извлекает.
Именно этот способ используют языки высокого уровня.

Передача параметров в потоке кода заключается в том, что данные, передаваемые в ПП, располагаются сразу за командой обращения к ПП call.
ПП, чтобы использовать эти данные, должна обратиться к ним по адресу, который записывается в стек автоматически как адрес возврата из ПП.
Но ПП в этом случае должна перед командой возврата изменить адрес возврата на адрес байта, следующий за передаваемыми параметрами. Этот метод реализует передачу
параметров медленнее, чем через регистры, глобальные переменные или стек, но примерно также, как и метод передачи параметров в блок параметров.

Блок параметров - это участок памяти, содержащий параметры и располагающийся обычно в сегменте данных.

Процедура получает адрес начала этого блока при помощи любого из рассмотренных методов: в регистре, в переменной, в стеке, в коде или даже в другом блоке параметров.
Примеры использования этого способа - многие функции ОС и BIOS, например, поиск файла, использующий блок параметров DTA, или загрущка и исполнение программы, использующая блок параметров EPB.

\subsection{Передача параметров по значению и по ссылке}

При передаче параметров по значению процедуры передается значение фактического параметра, оно копируется в ПП, и ПП использует копию, поэтому изменение, модификация параметра
оказывается невозможным. Этот механизм используется для передачи параметров небольшого размера.

Например, нужно вычислить \textbf{c = max(a, b) + max(7, a-1)}. Здесь все числа знаковые, размером в слово. Используем передачу параметров через регистры. Процедура получает параметры через
регистры. Процедура получает параметры через регистры AX и BX, результат возвращается в регистр AX.
Процедура:
\begin{minted}{asm}
    AX = max(AX, BX)
    max proc
        cmp AX, BX
        jge met1
        mov AX, BX
        met1: ret
    max endp
\end{minted}

\section{Фрагмент вызывающей программы:}
-----------------
\begin{minted}{asm}
    ; c = max(a, b) + max(7, a-1)
    mov AX, a
    mov BX, b
    call max ; AX = max(a, b)
    mov c, AX ; c = max(a, b)
    mov AX, 7
    mov BX, a
    dec BX
    call max ; AX = max(7, a-1)
    add c, AX
\end{minted}
-----------------

\section{Передача параметров по ссылке.}

Оформим как процедуру вычисление \textbf{x = x div 16}

Процедура имеет один параметр-переменную х, которой в теле процедуры присваивается новое значение. Т.е. результат записывается в некоторую ячейку памяти. И чтобы обратиться к процедуре с различными параметрами, например,
a и b, ей нужно передавать адреса памяти, где хранятся значения переменных a и b. Передавать адреса можно любым способом, в том числе и через регистры. Можно использовать различные регистры, но чаще используются BX, BP, SI, DI.
Пусть адрес параметра передается через регистр ВХ, тогда фрагмент программы:
\begin{minted}{asm}
    ; основная программа
    --------------------
    lea RBX, a
    call Proc_div
    lea BX, b
    call Proc_dv
\end{minted}

Процедура:
\begin{minted}{asm}
    Proc_dv proc
        push CX
        mov CL, 4
        shr word ptr [BX], CL ; x = x div 16
        pop CX
        ret
    Proc_dv endp
\end{minted}
Сдвиг на 4 разряда вправо эквивалентен делению нацело на 16 и выполняется быстрее.

Здесь первая команда в процедуре сохраняет в стеке значение регистра СХ, так как затем использует CL в команде сдвига и возможно этот регистр используется в основной программе.

Т.к. регистров немного а и ПП, и основная программа могут использовать одни и те же регистры, то при входе в ПП нужно сохранять в стеке значения регистров, которые будут использоваться в ПП, а перед выходом из нее восстанавливать значениях этих регистров.
Для поддержки  этого, начиная с ix186, в систему команд введены команды сохранения в стеке и извлечения из него сразу всех регистров общего назначения
\textbf{pusha} и \textbf{popa}, а, начиная с ix386, \textbf{pushad popad}.

Не нужно сохранять в стеке значение регистра, в который записывается результат работы ПП.

\section{Передача параметров по ссылке в блоке параметров}

Если параметров много, например, массив, адрес начала массива как блока параметров, можно передать через регистр, даже если результат ПП не будет записываться по этому адресу.

Даны два массива целых положительных чисел без знака
\begin{minted}{asm}
    X db 100 dup (?)
    Y db 50 dup (?)
\end{minted}

Вычислить DL = max(X[i]) + max(Y[i]), использовав процедуру max(A[i]), пересылая адрес массива через регистр ВХ, а результат сохраняя в AL.
\begin{minted}{asm}
    ; фрагмент программы
    lea BX, X
    mov CX, 100
    call max ; AL = max(X[i])
    mov DL, AL ; DL = max(X[i])
    lea BX, Y
    mov CX, 50
    call max
    add DL, AL
\end{minted}

Процедура max: AL = max(A[0..n-1]), BX - начальный адрес CX = n

\begin{minted}{asm}
    max proc
        push CX
        push BX
        mov AL, 0 ; начальное значение max
        met1:
        cmp [BX], AL
        jle met2
        mov AL, [BX]
        met2:
        inc BX
        loop met1
        pop BX
        pop CX
        ret
    max endp
\end{minted}

\section{Передача параметров в стек.}

Этот способ передачи параметров называют универсальным, его можно использовать при любом количестве параметров, хотя он сложнее, чем передача параметров через регистры.
Но для передачи результатов чаще используют регистры.

Если ПП имеет k параметров PP(a1, a2, ..., ak) размером в слово и параметры сохраняются в стеке в последовательности слева направо, то команды, реализующие обращение к ПП, должны быть следующими:

\begin{minted}{asm}
    ; обращение к процедуре PP
    push a1
    push a2
    ---------
    push ak
    call pp
    av:------
\end{minted}

содержимое стека при входе в pp
\begin{figure}
    \includegraphics{}
\end{figure}

Обращение к параметрам в процедуре можно осуществить с помощью регистра BP, присвоив ему значение SP.

Но при этом мы испортим старое значение BP, которое может быть используется в основной программе. Поэтому следует в начале сохранить старое значение ВР в стеке, а затем использовать его
для доступа к параметрам, т.е. тело процедуры долно начинаться следующими командами:
\begin{minted}{asm}
    PP proc near
        push BP
        mov BP, SP
        ----------
        ret
    PP endp
\end{minted}

в стеке после выполнения этих команд
\begin{figure}
    \includegraphics{}
\end{figure}

Для доступа к последнему параметру можно использовать выражение [BP + 4], например, mov AX, [BP + 4] ; ak -> AX
После "входных действий" в ПП идут команды, реализующие вспомогательный алгоритм, а за ними д.б. команды, реализующие "выходные действия":

\begin{minted}{asm}
    PP proc near
        push BP
        mov BP, SP
        ----------
        pop BP
        ret 2 * k
    PP endp
\end{minted}

n в команде \textbf{ret n} - это количество освобождаемых байтов в стеке, поэтому количество параметров д.б. умножено на длину параметра...
Команда ret вначале считывает значение av, а затем удаляет из стека параметры. Очистку стека можно выполнять не в ПП, а после выхода из нее, в основной программе, сразу после команды call PP, например, командой \textbf{add SP, 2 * k}

Каждый способ имеет свои достоинства и недостатки, если в ПП, то исполняемый код будет короче, если в основной программе, то можно вызвать ПП несколько раз с одними и теме же параметрами последовательными командами \textbf{call...}

Для удобства использования параметров, переданных через стек, внутри ПП можно использовать директиву equ, чтобы при каждом обращении к параметрам не писать точное смещение относительно BP.

\begin{minted}{asm}
    push x
    push y
    push z
    call PP
    ---------

    PP proc near
        push BP
        mov BP, SP
        pp_x equ [BP+8]
        pp_y equ [BP+6]
        pp_z equ [BP+4]
        ---------------
        mov AX, pp_x
        ---------------
        pop BP
        ret 6
    PP endp
\end{minted}

\section{Пример передачи параметров через стек.}

Пусть процедура заполняет нулями массив A[0..n-1], основная программа обращается к ней для обнуления массивов X[0..99] и Y[0..49]. Через стек в ПП передается имя массива и его размер, размер можно передавать по значению,
а имя массива нужно передавать по ссылке, т.к. этот параметр является и входным, и выходным.
\begin{minted}{asm}
    ; процедура zero_1
    zero_1 proc
        push BP ; входные
        mov BP, SP ; действия
        push BX ; сохранение значений
        push CX ; регистров
        mov CX, [BP+4] ; СХ = n считывание из стека
        mov BX, [BP+6] ; ВХ = А параметров
        m1:
        mov byte ptr [BX], 0 ; цикл обнуления
        inc BX ; массива
        loop m1 ; A[0..n-1]
        ; восстановление регистров и выходные действия
        pop CX
        pop BX
        pop BP
        ret 4
    zero_1 endp

    Фрагмент основной программы:
    X db 100 dup (?)
    Y db 50 dup (?)
    ---------------
    lea AX, X ; загрузка параметров:
    push AX ; адреса массива Х
    mov AX, 100 ; и его размера
    push AX ; в стек
    call zero_1 ; обращение к ПП
    lea AX, y ; загрузка параметров для массива Y
    push AX
    mov AX, 50
    push AX
    call zero_1 ; обращение к ПП
    ----------------
\end{minted}

\section{О передаче параметров в ПП}
\begin{enumerate}
    \item Передача по значение 
    \begin{minted}{asm}
        mov AX, word ptr value
        call PP
    \end{minted}
    \item Передача по ссылке
    \begin{minted}{asm}
        mov AX, offset value
        call PP
    \end{minted}
    \item Передача аргументов по возвращаемому значению объединяет передачу по значению и по ссылке: процедуре передается адрес переменной, она делает локальную копию этого параметра, работает с этой копией, а в конце процедуры записывает эту копию по переданному адресу. Этот механизм оказывается эффективным, если процедуре приходиться много раз обращаться к параметру в глобальной переменной.
    \item Передача параметров по результату заключается в том, что в ПП передается адрес только для записи по этому адресу результата работы ПП.
    \item Передача параметров по имени макроопределения. Пример:
    \begin{minted}{asm}
        name macro parametr
            mov AX, parametr
        name endm
    \end{minted}
    Обращение к ПП может быть таким:
    \begin{minted}{asm}
        name value ; обращение к макро
        call PP ; обращение к ПП
    \end{minted}
    \item Передача параметров отложенным вычислением. Как и в случае передачи параметров по имени, процедура получает адрес ПП, вычисляющей значение параметра. Этот механизм чаще используется в системах искусственного интеллекта и в ОС.
\end{enumerate}

\section{Использование локальных параметров.}

Если локальных параметров несколько, то их размещают в регистрах, но если их много, то возможны различные варианты: им можно отвести место в сегменте данных, но тогда большую часть времени эта область памяти не будет использоваться.
Лучший способ - разместить локальные параметры в стеке на время работы ПП, а перед выходом из ПП их удалить. Для этого после входных действий в процедуре нужно уменьшить значение указателя на вершину стека SP на количество байтов, необходимых для хранений локальных величин и затем записывать их в стек и извлекать их можно с помощью выражений вида: [BP - n], где n определяет смещение локального параметра относительно значения BP.

Например, если предполагается, что ПП будет использовать 3 локальных параметра размером в слово, то стек графически можно представить так:
\begin{figure}
    \includegraphics{}
\end{figure}
При выходе из процедуры перед выполнением завершающих действий нужно возвратить регистру SP его значение.

Если в стеке хранятся и фактические, и локальные параметры, то начало процедуры и ее завершение должны выглядеть следующим образом:
\begin{minted}{asm}
    PP proc
        push BP ; сохранить старое значение ВР
        mov BP, SP ; кладём SP в ВР
        sub SP, k1 ; отвести в стеке k1 байтов под локальные параметры
        push AX
        --------------
        <тело процедуры>
        --------------
        pop AX
        mov SP, BP ; восстановить SP, т.е. освободить место
                ; в стеке от локальных параметров
        pop BP ; восстановить ВР, равным до обращения к ПП
        ret k2 ; очистка стека от фактических параметров и возврат в вызывающую программу
    PP endp
\end{minted}

\section{Подсчет количества различных символов в заданной строке.}

Строка задана как массив символов. Начальный адрес ее передадим в ПП через регистр BX, длину строки через СХ, а результат - через АХ. Создадим процедуру, в которой выделяется 256-ый локальный массив L по количеству возможных символов.
К-ому элементу этого массива будем присваивать единицу, если символ, цифровой код которого равен К, в заданной строке существует. Затем подсчитаем количество единиц в этом массиве. Вначале весь массив обнуляется.
К первому элементу этого массива можно обратиться так: \textbf{L1 = [BP-256] к К-ому Lk = [BP-256 + k]}
Работая со строками, эту задачу можно решить проще.
\begin{minted}{asm}
    Count_s proc ; входные действия
        push BP
        mov BP, SP
        sub SP, 256
        push BX
        push CX
        push SI
        ; Обнуление локального массива
        mov AX, CX
        mov CX, 256
        mov SI, 0
        m1:
        mov byte ptr [BP - 256 + SI], 0
        inc SI
        loop m1 ; просмотр заданной строки и запись 1 в локальный массив
        mov CX, AX ; длину строки в СХ
        mov AX, 0
        m2:
        mov AL, [BX] ; код очередного символа в AL
        mov SI, AX ; пересылаем его в SI
        mov byte ptr[BP - 256 + SI], 1 ; пересылаем 1 в к-ый элемент массива
        inc BX
        loop m2
        ; подсчет количества 1 в локальном массиве
        mov AX, 0 ; результат будет в АХ
        mov CX, 256 ; количество повторений цикла
        mov SI, 0 ; индекс массива в SI
        m3:
        cmp byte ptr[BP - 256 + SI], 1
        jne m4
        inc AX
        m4:
        inc SI
        loop m3
        ; выходные действия
        pop SI
        pop CX
        pop BX
        mov SP, BP
        pop BP
        ret
    Count_s endp
\end{minted}

\section{Рекурсия в Ассемблере}

Основные трудности, возникающие при реализации рекурсии - это опасность "зацикливания" рекурсии и использование параметров. Зацикливания не произойдет,
если в процедуре есть рекурсивная и не рекурсивная ветви и при выполнении некоторого условия вычислительный процесс пойдет по не рекурсивной ветви. Рекурсивное обращение ПП можно представить, если предположить,
что при каждом обращении создается копия ПП и адреса возврата сохраняются в стеке. А структура стека позволяет извлекать их в последовательности, обратной поступлению.

Также решается и проблема с параметрами. В рекурсивную процедуру нельзя передавать параметры через ячейки памяти в сегменте данных, а если такая необходимость возникает, то при входе в ПП их необходимо сохранять в стеке, а при выходе из нее восстанавливать.
Это значит, что лучше сразу параметры передавать через стек.

Пример рекурсивной функции:
\begin{minted}{asm}
    F(n) = 1, если n = 0 или n = 1 и
    F(n) = F(n - 1) + F(n - 2), если n > 1
\end{minted}

Вычисление n-го ряда Фибоначчи:
\begin{minted}{asm}
    Fib proc ; BX = F(n), AL = n
        cmp AL, 1
        ja m1 ; если n > 1, m1
        ; нерекурсивная ветвь
        mov BX, 1 ; если n < 1 или n = 1
        ret
        ; рекурсивная ветвь
        m1:
        push AX
        dec AL ; AL = n - 1
        call Fib ; BX = F(n - 1)
        dec AL ; AL = n - 2
        call Fib ; BX = F(n - 2)
        pop AX ; AX = F(n - 1)
        add BX, AX ; BX = F(n - 2) + F(n - 1)
        pop AX ; восстановить AX
        ret
    Fib endp
\end{minted}


\section{Работа со строками}

Строка - это последовательность  байтов, слов или двойных слов. Все команды для работы со строками считают, что строка-источник находится по адреса \textbf{DS:SI (DS:ESI)}, а строка приемник - по адресу \textbf{ES:DI (ES:EDI)}

Все команды работают с одним элементом строки: одним байтом, одним словом или одним двойным словом в зависимости от команды и/или от типа операндов.

Чтобы выполнить действие над всей строкой, слева от команды записывается специальный префикс.

Префикс - это команда повторения операции. Префикс действует только на команды работы со строками, поставленный рядом с любой другой конмадой он никак не влияет на ее выполнение.

Существуют следующие префиксы:
\begin{minted}{asm}
    \textbf{rep} - повторять
    \textbf{repe} - повторять пока равно
    \textbf{repz} - повторять пока ноль
    \textbf{repne} - повторять пока не равно
    \textbf{repnz} - повторять пока не ноль
\end{minted}

\begin{enumerate}
    \item Префикс повторять \textbf{rep <строковая команда>} заставляет повторяться указанную команду n раз, где n - содержимое регистра \textbf{CX (ECX)}. Если \textbf{(CX) = 0}, то команда не выполнится ни разу.
    \item \textbf{repe <стр. команда> = repz <стр. команда>}
    Указанная строковая команда будет повторяться до тех пор, пока флаг ZF = 1, но не более n раз, где n = (CX) или (ECX). Работу команды с этими префиксами можно на псевдокоде описать так:
    \begin{minted}{asm}
        m: if (CX) = 0 then goto m1;
        (CX) = (CX) - 1;
        <стр. команда>;
        if ZF = 1 then goto m;
        m1:------------------
    \end{minted}
    \item \textbf{repne <стр. команда> = repnz <стр. команда>}
    Указанная строковая команда повторяется до тех пор, пока флаг ZF = 0, но не более n раз, где n - содержимое счетчика CX (ECX).
\end{enumerate}

Семантика этих префиксов на псевдокоде:

\begin{minted}{asm}
    m: if (CX) = 0 then goto m1;
    (CX) = (CX) - 1
    <стр. команда>;
    if ZF = 0 then goto m;
    m1: -----------------
\end{minted}
Префикс \textbf{rep} используется обычно с командами:
\textbf{movs, lods, stos, ins и outs}
Префиксы \textbf{repe, repz, repne, repnz} с командами \textbf{cmps и scas}.
\subsection{Команды копирования для строк.}
\begin{enumerate}
    \item \textbf{movs op1, op2} ; источник op2 = DS:SI (DS:ESI), приемник op1 = ES:DI (ES:EDI)
    \item \textbf{movsb} ; байт данных из (DS:SI) пересылается в ES:DI
    \item \textbf{movsw} ; слово данных из (DS:SI) пересылается в ES:DI
    \item \textbf{movsd} ; двойное слово данных из (DS:SI) пересылается в ES:DI
\end{enumerate}

При использовании команды 1) - movs Ассемблер сам определяет по типу указанных в команде операндов сколько байтов данных нужно переслать - 1, 2 или 4.

В этой команде можно изменить DS на другой регистр: ES, GS, FS, CS, SS, но регистр операнда приемника ES изменить нельзя.
Чаще команды для строк используются без операндов.
После выполнения любой команды со строками содержимое регистров SI и DI автоматически изменяется в зависимости от значения флажка DF.
Если DF = 0, то (SI/ESI) и (DI/EDI) увеличивается на 1, или 2, или 4,
Если DF = 1, то (SI/ESI) и (DI/EDI) уменьшается на 1, или 2, или 4 в зависимости от операндов или кода команды.

\section{Команды сравнения строк.}
\begin{enumerate}
    \item cmps op1, op2 ;
    \item cmpsb ; сравнение байтов
    \item cmpsw ; сравнение слов
    \item cmpsd ; для i386 и > сравнение двойных слов
\end{enumerate}

По команде 1) в зависимости от типа операндов сравнивается содержимое байтов, слов или двойных слов, расположенных по адресам источник и приемника.

В остальном команды сравнению работают так же, как и команды пересылки. Эти команды используются с префиксами
\begin{enumerate}
    \item \textbf{repe / repz} и
    \item \textbf{repne / repnz}
\end{enumerate}
При использовании префиксов 1) сравнение идет до первого не совпадения, 2) - до первого совпадения.
Команды:
\begin{enumerate}
    \item \textbf{scas op1} ; op1 - приемник
    \item \textbf{scasb} ; сравнивает (AL) с байтом из ES:DI / ES:EDI
    \item \textbf{scasw} ; сравнивает (АХ) со словом из ES:DI / ES:EDI
    \item \textbf{scasd} ; для i386 и выше, сравнивает (EAX) с двойным словом из ES:DI / ES:EDI
\end{enumerate}
При работе команды 1) количество сравниваемых байтов зависит от разрядности операнда.
Команды \textbf{cmps и scas} устанавливают флаги аналогично команде \textbf{cmp}.

\section{Команды считывания строки из памяти и загрузки в регистр AL, AX или EAX}

\begin{enumerate}
    \item lods op2; op2 - источник DS:SI или DS:EDI
    \item lodsb ; 1 байт из DS:SI или DS:EDI -> AL
    \item lodsw ; 2 байта из DS:SI или DS:EDI -> AX
    \item lodsd ; 4 байта из DS:SI или DS:EDI -> EAX
\end{enumerate}
lods op2 работает как lodsb или lodsw или lodsd в зависимости от типа операнда и здесь DS можно заменить на ES, FS, GS, CS или SS.
Команды записи строки из регистра AL, AX или EAX в память по адресу ES:DI или ES:EDI
\begin{enumerate}
    \item stos op1
    \item stosb
    \item stosw
    \item stosd ; для i386 и выше
\end{enumerate}
При использовании этих команд с префиксом rep строка длиной в (CX) (ECX) ячеек заполнится числом, хранящимся в аккумуляторе AL, AX или EAX

\section{Считывание из порта ввода/вывода}
\begin{enumerate}
    \item ins op1, DX
    \item insb
    \item insw
    \item insd ; i386 и > 
\end{enumerate}

Эти команды считывают из порта ввода/вывода, номер которого содержится в регистре DX, байт (insb), слово (insw) или двойное слово (insd) и пересылает их в память по адресу ES:DI или ES:EDI.
Команда 1) принимает одну из форм 2), 3), 4) в зависимости от типа операнда.

При использовании с префиксом rep она считывает из порта ввода/вывода блок данных (байтов, слов или двойных слов) длиной, определяемой регистром CX (ECX) и пересылает в память по адресу приемника.

Запись в порт в/в содержимого ячейки памяти, размером в байт, слово или двойное слово, находящейся по адресу DS:SI или DS:EDI
\begin{enumerate}
    \item outs DX, op2
    \item outsb
    \item outsw
    \item outsd ; i386 и >
\end{enumerate}

Номер порта в командах работы с портами в/в должен находиться в регистре DX

В команде outs можно заменить DS на ES, FS, GS, CS или SS. Используя префикс rep можно переслать в порт блок данных, размером в (CX) или (ECX) байтов, слов или двойных слов.

\section{Команды управления флагами.}

После выполнения команд со строками изменяется содержимое регистров-индексов в зависимости от значения флажка направления DF. Автоматически его значение не изменяется, его должен изменить программиист с помощью команд:
\begin{minted}{asm}
    cld ; CLear Df, DF = 0
    std ; SeT Df, DF = 1
\end{minted}
Программист может установить следующие флажки:
\begin{minted}{asm}
    stc ; CF = 1
    clc ; CF = 0
    cmc ; инвертировать флаг переноса
    lahf ; копирует младший байт регистра FLAGS в AH
    sahf ; из AH загружает флажки SF, ZF, AF, PF, CF
    cli ; IF = 0
    sti ; IF = 1
    salc ; установить регистр AL в соотвествии с CF
\end{minted}

\subsection{Загрузка сегментных регистров}
\begin{minted}{asm}
    lds op1, op2
    les op1, op2
    lfs op1, op2
    lgs op1, op2
    lss op1, op2
\end{minted}

Для всех команд op2 - переменная в ОП размером в 32 или 48 бит в зависимости от разрядности операндов. Первые 16 бит этой переменной загружаются в соотвеющий сегмент DS, ES и т.д., а следующие 16 или 32 - в регистр общего назначения,
указанный в качестве первого операнда. В защищенном режиме значение, загружаемое в сегментный регистр, всегда должно быть правильным селектором сегмента, в реальном режиме любое число может использоваться как селектор.

\subsection{Загрузка сегментных регистров (пример)}
\begin{minted}{asm}
    S1 db "ABC$"
    ADR dd S1
    les DI, ADR
\end{minted}

В переменную ADR записывается полный адрес, определяемый именем S1 (Seg:Ofs). B ES записывается значение сегментной части адреса S1, а в DI ее смещение.

Пример 1. Использование команд работы со строками:
\begin{minted}{asm}
    X dw 100 dup (?)
    Y dw 100 dup (?)
\end{minted}
Выполнить пересылку содержимого одной области памяти в другую
X = Y:
\begin{minted}{asm}
    ----------------
    cld ; DF = 0
    lea SI, Y ; DS:SI - начало Y
    push DS
    pop ES ; (ES) = (DS)
    lea DI, X
    mov CX, 100
    rep movsw
    ----------------
\end{minted}

Пример 2. В строке S, состоящей из 500 символов заменить первое вхождение звездочки на точку.

\begin{minted}{asm}
    ----------------
    cld ; просмотр строка слева направо
    push DS
    pop ES
    lea DI, S
    mov CX, 500
    mov AL, '*'
    repne scasb ; сканирование строки S и сравнение с (AL)
    jne finish ; '*' в строке нет
    mov byte ptr ES:[DI-1], '.'
    finish: --------
\end{minted}

Здесь используется выражение [DI-1] т.к. после того, как звездочка найдена, DI увеличивается на 1 и указывает на следующий символ.

\subsection{Строки переменной длины}

Строка в языке Ассемблера может быть реализована по аналогии с тем, как это сделано в языке C/C++ и как в языке Паскаль. В C/C++ за запоследним символом строка располагают специальный символ, являющийся признаком конца строки.
Изменение длины строки сопровождается переносом этого символа. Недостатком такого представления строк переменной длины является то, что, например, для сравнения строк S1 и S2, длиной 500 и 1000 символов необходимо выполнить может быть 500 сравнений, хотя зная,
что длина их различна, их можно было совсем не сравнивать.
В Паскале строка представляется так:
S
\begin{figure}[H]
    \includegraphics{}
\end{figure}
Где n - текущая длина. Сколько места необходимо отводить под значение длины строки n - зависит от максимально возможной длины. Если она может состоять не более, чем из 255 символов, то под n достаточно одного байта.
Тогда текущая длина строки содержится по адресу S, а ее i-ый символ по адресу S + i. Строку из 200 символов можно описать так:
\begin{minted}{asm}
    S db 201 dup (?)
\end{minted}

Пример 3. Удалить из строки S первое вхождение символа звездочка.
\begin{minted}{asm}
    ----------------
    ; поиск '*'
    push DS
    pop ES ; (ES) = (DS)
    lea DI, S + 1 ; ES:DI = адресу S[1]
    cld ; просмотр вперёд
    mov CL, S ; текущая длина строки
    mov CH, 0 ; в CX
    mov AL, '*'
    repne scasb ; поиск '*' в S
    jne finish ; '*' в S нет -> на метку finish
    ; удаление '*' из S, сдвинуть S на 1 символ S[i] = S[i + 1]
    mov SI, DI : DS:SI = адресу, откуда начинать пересылку
    dec DI ; ES:DI = куда пересылать
    rep movsb ; сдвиг "хвоста" S на 1 позицию влево
    dec S ; уменьшить на 1 текущую длину
    finish: --------
\end{minted}

\section{Представление и работа со списками в  Ассемблере}

Односвязный линейный список представляют в виде:
\begin{figure}[H]
    \includegraphics{}
\end{figure}

Стандартных процедур для работы со списками в языке Ассемблера нет, их нужно реализовывать самим. Динамические переменные, располагаются в специальной области ОП, называемой кучей (heap). Размер кучи зависит от количества использованных в программе динамических переменных, будем считать от количества и длины списков.

Предположим, что для кучи достаточно 64 Кб, тогда пусть начало кучи определяет сегментный регистр ES. Если внутри кучи элемент списка имеет адрес (смещение) А, то абсолютный физический адрес этого элемента определяется адресной парой ES:A.
Так как в этих адресных парах для всех элементов общим является начало кучи ES, то будем считать адресом элемента спика 16-разрядное смещение А.

Под каждый элемент списка отводится фиксированное количество байтов, пусть информационное поле определяется именем elem и занимает 2 байта, тогда элемент списка можно описать как структуру:
\begin{minted}{asm}
    node struc ; тип элемента списка
        elem dw ? ; информационное поле
        next dw ? ; ссылочное поле
    node ends
\end{minted}

Если А описана с помощью директивы node: \textbf{A node <>}, то доступ к полям элемента списка с адресом А осуществляется так:
\begin{minted}{asm}
    ES: A.elem ;
    ES: A.next ;
\end{minted}

Пустая ссылка - это адрес 0, определив константу \textbf{NULL equ 0}, 
пользуемся для обозначения пустой сыслка константой NULL, как и в C++.

Ссылки на превые элементы списков описывают обычно в сегменте данных DS как переменные, размером в слово:
\begin{minted}{asm}
    nsp dw ? ;
    list dw ? ;
\end{minted}

При работе со списками просматриваются элементы один за другим, так что необходимо знать адрес текушего элемента. Используем для хранения этого адреса регистр BX, причем в BX будет храниться только смещение текущего элемента,
адрес отсчитанный от начала кучи, поэтому, чтобы обратиться к элементу списка, необходимо использовать выражение ES: [BX], если укажем просто [BX], то по умолчанию этот адрес будет выбираться из сегмента DS.

Обращение к полям текущего элемента это:
\begin{minted}{asm}
    ES:[BX].elem и ES:[BX].next
\end{minted}

Основные операции:
\begin{enumerate}
    \item Анализ информационного поля:
    \begin{minted}{asm}
        ----------------
        mov AX, ES:[BX].elem ; сравнение информационного поля
        cmp AX, X ; со значением X
        je jes ; если совпали, то переход на jes
        ----------------
    \end{minted}
    \item Переход к следующему элементу:
    \begin{minted}{asm}
        mov BX, ES:[BX].next
    \end{minted}
    \item Проверка на конец списка:
    \begin{minted}{asm}
        cmp BX, NULL
        je list_end ;
    \end{minted}
    \item Поиск элемента с заданным значением информационного поля
    nsp - начало списка, x - искомая величина, в AL - результат = 1, если такой элемент в списке есть, или 0, если такого элемента нет.
    \begin{minted}{asm}
        ----------------
        mov AL, 0
        mov CX, x
        mov BX, nsp ; BX = null, или адрес первого элемента
        L: cmp BX, null
        je no ; если BX = null, то на метку no
        cmp ES:[BX].elem, CX
        je jes ; [BX].elem = x, то на метку jes
        mov BX, ES:[BX].next ; BX = BX.next
        jmp L ; на повторение цикла пока не конец списка
        jes: mov AL, 1
        no: ------------
    \end{minted}
    \item Вставка нового элемента в начало списка
    В Ассемблере нужно самим написать процедуру new, которая выделяет место в куче для размещения нового элемента. Пусть такая процедура с именем new есть, она без параметров и результатом ее является адрес байта в куче,
    начиная с которого можно разместить новый элемент списка. Этот адрес передается вызывающей процедуре через регистр DI. Тогда вставить элемент в начало списка:
    \begin{minted}{asm}
        call new ;
        mov AX, x
        mov ES:[DI].elem, AX
        mov AX, nsp
        mov ES:[DI].next, AX
        mov nsp, DI
    \end{minted}
    \begin{figure}[H]
        \includegraphics{}
    \end{figure}
    \item Удаление элемента из списка.
    Пусть для адреса 1-го элемента используем BX, адреса 2-го элемента DI и есть уже процедура dispose (DI), удаляющая элемент из списка, т.е. освобождающая место в куче для дальнейшего использования, тогда удаление второго элемента можно реализовать так:
    \begin{minted}{asm}
        ----------------
        mov BX, nsp ; адрес первого элемента в BX
        cmp BX, null ; if nsp = null, список пуст
        je finish

        mov DI, ES:[BX].next ; DI = null, или адресу 2-го элемента
        cmp DI, null ; если DI = null, 2-го элемента нет
        je finish

        mov AX, ES:[DI].next
        mov ES:[DI].next, AX
        call dispose ; освобождение памяти
        
        finish:----------
    \end{minted}
    \begin{figure}[H]
        \includegraphics{}
    \end{figure}
\end{enumerate}

\subsection{Организация "кучи" и процедур создания и удаления динамических переменных}

При выполнение программы, занятые и свободные ячейки в куче, располагаются не последовательно, а произвольно, так как различные элементы списка могут удаляться и также произвольно создаваться.
Чтобы определить, какие же ячейки кучи свободны, удобнее всего все свободные ячейки кучи объединить в один список. Его называют списком свободной памяти (ССП). Адрес начала списка хранится в фиксированной ячейке с именем heap_ptr.
Если программе необходимо место под очередной элемент в некотором списке, это место выделяется из ССП, если удаляется некоторый элемент, то он добавляется к ССП. Т.е. ССП можно представить как обычный список, для простоты с элементами такой же структуры.
\begin{figure}[H]
    \includegraphics{}
\end{figure}

Осталось определить, где располагается переменная heap_ptr - указатель на ССП. Лучше всего отвести ей место в самом начале куче, в ячейке с относительным адресом 0.

Описание сегмента кучи, в котором может разместиться n элементов размером в двойное слово, может быть таким:
\begin{minted}{asm}
    Heap_size equ n ; n - количество элементов в списке
    heap segment
    Heap_ptr dw ? ; ячейка с начальным адресом ССП
    dd heap_size dup (?) ; n слов в куче
    Heap ends
\end{minted}

Так описали сегмент кучи, адрес начала кучи должен храниться в регистре ES и программист сам должен загрузить его в этот сегмент. Кроме того, байты этого сегмента нужно объединить в список ССП, например, так чтобы первая ячейка была первым элементом ССП и т.д. Heap_ptr имеет нулевой относительный адрес.
\begin{figure}[H]
    \includegraphics{}
\end{figure}

Инициализация кучи и загрузка её начала в ES:
\begin{minted}{asm}
    init_heap proc far
        push SI
        push BX
        push CX
    ; установка ES на начало кучи
        mov CX, heap
        mov ES, CX
    ; объединение всех двойных слов в ССП
        mov CX, heap_size
        mov BX, null
        mov SI, 4 * heap_size - 2
        in1:
        mov ES:[SI].next, BX
        mov BX, SI
        sub SI, 4
        loop in1
        mov ES:heap_ptr, BX
        pop CX
        pop BX
        pop SI
        ret
    init_heap endp
\end{minted}

К процедуре init_heap необходимо обращаться до обращения к процедурам new и dispose.

Процедура создания динамической переменной:
\begin{minted}{asm}
    ; на выходе процедуры в DI будет адрес нового элемента
    new proc far
        mov DI, ES:heap_ptr ; DI = null или адресу 1-го элемента
        cmp DI, null
        je empty_heap ; если ССП пусть -> empty_heap
        push ES:heap_ptr ; указатель на второй элемент кучи
        ret
        empty_heap:
        lds DX, CS:aerr ; реакция на пустую кучу
        ; DS:DX - адрес сообщения об ошибке
        outstr ; макрос вывода этого сообщения
        finish ; макрос останова программы
        aerr dd err ; абсолютный адрес сообщения
        err db 'ошибка в new: исчерпание кучи', '$'
    new endp
\end{minted}

\subsection{Процедура освобождения динамической памяти dispose}

Процедуре \textbf{dispose} адрес удаляемого элемента передается в регистре DI, освобождаемая память присоединяется к ССп в его начало, как к односвязному списку:
\begin{minted}{asm}
    dispose proc far
    ; на входе адрес удаляемого элемента в регистре DI
        push ES:heap_ptr
        pop ES:[DI].next ; DI.next = heap_ptr
        mov ES:heap_ptr, DI ; heap_ptr = DI
    dispose endp
\end{minted}

Все процедуры рассчитаны на случай, когда все элементы всех списков имею один и тот же размер. Если в программе используются списки с элементами различного размера, то все процедуры будут сложнее, но принцип тот же.

\section{Макросредства языка Ассемблер}

Макросредства называют самым мощным средством программирования в Ассемблере. Они позволяют генерировать, модифицировать текст программы на Ассемблере в процессе трансляции программы.

К макросредствам относят: блоки повторений, макросы, директивы условной генерации.

Программы, написанные на макроязыке, транслируются в два этапа. Сначала она переводится на "чистый" язык Ассемблера, т.е. преобразуется к виду, в котором нет никаких макросредств, этот этап называют макрогенерацией. Затем выполняется ассемблирование - перевод в машинные коды. Макрогенерацию называют еще \textbf{препроцессорный обработкой}.
\textbf{Блоки повторения} в процессе макрогенерации заменяются указанной последовательностью команд столько раз, сколько задано в заголовке блока. Набор команд повторяется n раз в том месте программы, где указан блок повторения.

\textbf{Макросы} более похожи на ПП. Аналогично ПП существует описание макросаи обращение к нему. Описание макроса называют \textbf{макроопределением}, а обращение - \textbf{макрокомандой}. Процесс замены макрокоманды на макрос - \textbf{макроподстановкой}, а результат этой подстановки - \textbf{макрорасширением}.

Макроопрелеление не порождает никаких машинных команд, оно должно предшествовать первой макрокоманде, использующей это макроопределение, и может располагаться как непосредственно в тексте программы, так и может быть подключено из другого файла с помощью директивы \textbf{include <имя файла>}.

\textbf{Основное отличие} макроса от процедуры заключается, \textbf{во-первых}, в том, что при обращении к ПП управление передаётся на участок памяти, в котором содержится описание ПП, а при обращении к макросу его тело(макроопределение) вставляется на место макрокоманды, т.е. сколько раз мы обратимся к макросу, сколько макрокоманд будет в программа, столько раз повторится макроопределение, вернее, макрорасширение.
Макрос "размножается", увеличивая размер программы. Таким образом, применение процедур дает выигрыш по памяти, но использование макросов дает выигрыш по времени, т.к. нет необходимости передавать управление в ПП и обратно (call и ret), а также организовывать передачу параметров.

Рекомендация: если повторяются большие фрагменты программ, лучше использовать процедуры, если относительно небольшие, то макросы.

\textbf{Второе отличие} заключается в том, что текст процедуры не изменен, а содержание макрорасширения зависит от параметров макрокоманды, если используются директивы условной генерации, и тогда это существенно.

\subsection{Блок повторений}
Общий вид блока повторений:
\begin{minted}{asm}
    <заголовок>
        <тело>
    endm
\end{minted}

<тело> - любое количество любых операторов, предложений, в том числе и блоков повторений.
endm определяет конец тела блока. Количество повторений тела и способ модификаций тела блока зависит от заголовка
Возможны следующие заголовки:
\begin{enumerate}
    \item rept n ; n-константное выражение
    Оно может быть вычислено на этапе макрогенерации, в результате которого n копий тела блока записывается в данном месте программы на Ассемблере. Например:
    \textunderscore{В исходной тексте}
    \begin{minted}{asm}
        N equ 8
        rept N-6
            db 0,1
            dw ?
        endm
    \end{minted}

    \textunderscore{После макрогенерации на этом месте}
    \begin{minted}{asm}
        N equ 8
        db 0,1
        dw ?
        db 0,1
        dw ?
    \end{minted}
    
    Для создания массива с начальными значениями от 0 до 0FFh достаточно написать блок повторений:
    \begin{minted}{asm}
        n = 1
        mas db 0 ; имя массива mas
        rept 255 ; начало блока
            db n
            n = n + 1
        endm
    \end{minted}
    \item Второй вид заголовка:
    \begin{minted}{asm}
        IRP p, <v1, v2, ..., vk> ; <> обязательные символы
            <тело> ; тело повторяется k раз так, что в i-ой копии
        endm
    \end{minted}
    формальный параметр p замещается фактическим параметром vi. Формальный параметр p - это локальное имя, не имеющее смысла вне блока. Если оно совпадает с именем другого какого-либо объекта программы, то в теле блока это просто имя, а не этот объект. Например:
    \begin{minted}{asm}
        irp reg, <AX, BX, CX, SI>
            push reg
        endm
        ; после макрогенерации
        push AX
        push BX
        push CX
        push SI
    \end{minted}
    Причём, замена формального параметра на фактический - это просто текстовые замены, один участок программмы Р заменяется на другой - Vi, т.е. P может обозначить любую часть предложения или всё предложение, лишь бы после замены P на Vi получилось правильное предложение языка Ассемблер.

    \item Вид заголовка: \textbf{irpc p, s1s2...sk}
    \begin{minted}{asm}
        irpc p, s1s2...sk
            <тело>
        endm
    \end{minted}
    P - формальный параметр, Si - символы, любые, кроме пробелов и точки с запятой, если необходимо использовать здесь пробел или точку с запятой, то надо всю последовательность символов записать в угловых скобках. Встречая такой блок, макрогенератор заменяет его на k копий тела так, что i-той копии параметр P заменен на символ Si. Например:
    \begin{minted}{asm}
        irpc A, 175P
            add AX, A
        endm
        ; после макрогенерации
        add AX, 1
        add AX, 7
        add AX, 5
        add AX, P
    \end{minted}
\end{enumerate}

\subsection{Макрооператоры}

В макроопределениях и в блоках повторений могут использоваться специальные операторы Ассемблера, называемые макрооператорами для записи формальных и фактических параметров.

\begin{enumerate}
    \item \textbf{& - амперсанд} - используется для того, чтобы указать границы формального параметры, выделить его из окружающего текста, при этом в текст программы он не записывается. Например:
    \begin{minted}{asm}
        ; a)
        irp W, <1, 5, 7>
            var&W dw?
        endm
        ; после макрогенерации
        var1 dw?
        var5 dw?
        var7 dw?

        ; б)
        irpc A, "<
            db 'A, &A, &A&B'
        endm
        ; после макрогенерации
        db 'A, ", "B'
        db 'A, <, <B'
    \end{minted}
    Здесь параметры W и A заменяются на фактические параметры только в том месте, где они выделены макрооператором &.

    Если знаков & рядом несколько, то макрогенератор удаляет за один проход только один из них, и это используется для организации вложенных циклов блоков повторений и макросов. Например:
    \begin{minted}{asm}
        irpc P1, AB
            irpc P2, HL
                inc P1&&P2
            endm
        endm
        ; после первой макрогенерации
        irpc P2, HL
            inc A&P2
        endm
        irpc P2, HL
            inc B&P2
        endm
        ; после второй макрогенерации
        inc AH
        inc AL
        inc BH
        inc BL
    \end{minted}
    \item \textbf{Макрооператор < >} - угловые скобки действует так, что весь текст, заключенный в эти скобки, рассматривается как одна текстовая строка, и в нее могут входить пробелы, запятые и другие разделители.
    Этот макрооператор часто используется для передачи текстовых строк в качестве параметров для макросов и для передачи списка параметров вложенному макроопределению или блоку повторений.
    \begin{minted}{asm}
        ; a)
        irp V, <<1, 2>, 3>
            db V
        endm
        ; после макрогенерации 
        db 1,2
        db 3

        ; b)
        irpc S, <A; B>
            db 'S'
        endm
        ; после макрогенерации
        db 'A'
        db ';'
        db 'B'
    \end{minted}
    Если в примере б) скобок <> не будет, то символ В будет восприниматься как комментарий после ;
    \item \textbf{Макрооператор !} - восклицательный знак используется аналогично угловым скобкам, но действует только на один следующий символ, так что, если этим символом является один из символов ограничения - запятая, угловая скобка и т.д., то он будет передаваться как параметр или часть параметра.
    \item \textbf{Макрооператор (символ процент)} - процент указывает на то, что следующий за ним текст является выражением, которое должно быть вычислено, и за результат передается как параметр. Например:
    \begin{minted}{asm}
        K equ 4
        ...
        irp A, <k + 1, % k + 1, W% k + 1>
            dw A
        endm
        ; после макрогенерации
        dw k + 1
        dw 5
        dw W5
    \end{minted}
    \item \textbf{Макроператор ;;} - две точки с запятой определяют начало макрокомментаряи. Текст макрокомментария не включается в макрорасширения и в листинг программы.
\end{enumerate}

\section{Макросы.}

Описание макрос, макроопределение, имеет вид:
\begin{minted}{asm}
    <имя макроса> macro <формальные параметры>
        local <список имен>
        <тело>
    endm
\end{minted}
Первая строка - это заголовок макроса, имя макроса будет использоваться для обращения к этому макроопределению. Формальные параметры записываются через запятую, это локальные имена, никак не связанные с объектами программы. Количество формальный параметров не ограничено, но они должны умещаться в одной строке.
Поскольку на место каждой макрокоманды записывается макрорасширение, кроме того, одни и те же метки могут использоваться и в самой программе, чтобы не возникало ошибки "метка уже определена", директива local <список имен> перечисляет через запятую имена меток, которые будут использоваться в теле макроса. <тело> - это копируемый фрагмент программы, любое количество любых предложений Я.А., в которых используются формальные параметры.
Макрокоманда - обращение к макросу:
<имя макроса> <фактические параметры>

\textbf{Фактические параметры} указываются через запятую или/и пробел. В качестве фактического параметра может быть использован любой текст, в том числе и пустой, но он должен быть сбалансирован по кавычкам и угловым скобкам, и в нем не должно быть запятых, пробелов и точек с запятой вне кавычек и скобок, т.к. запятая и пробел могут отделять один параметр от другого, а точкой с запятой начинается комментарий.
С помощью директивы exitm можно осуществить досрочный выход из макроса, если использовать команды условной генерации \textbf{if X ... endif}
С помощью директивы \textbf{purge <имя макроса>} можно отменить опреденный ранее макрос. Эта директива часто используется сразу после директивы include, включившейся в текст программы файл с большим количеством готовых макроопределений.

\subsection{Примеры макросов}
\begin{enumerate}
    \item Использование макросов позволяет составлять программу в терминах более крупных операций. Опишем в виде макроса оператор IF x < y the GOTO L.
    \begin{minted}{asm}
        IF_L macro x,y,L
            mov AX, x
            cmp AX, y
            jl L
        endm
    \end{minted}
    Испольхуя этот макрос, поиск минимального из 3-х чисел запишется так:
    \begin{minted}{asm}
        ; DX = min(A, B, C)
        mov DX, A
        IF_L A, B, m1
        mov DX, B
        m1:
        if_L DX, C, m2
        mov DX, C
        m2:----------------
        ; после макрогенерации
        mov DX, A
        mov AX, A
        cmp AX, B
        jl m1
        mov DX, B
        m1: mov AX, DX
        cmp AX, C
        jl m2
        mov DX, C
        m2: ---------------
    \end{minted}
    \item \textbf{Обращение к процедурам} будет нагляднее, если передачу параметров оформить как макрос.
    Например: вычислить CX = NOD(A, B) + NOD(C, D), если есть процедура NOD(x, y), и результат ее находится в АХ.
    \begin{minted}{asm}
        call_nod macro x, y
            mov AX, x
            mov BX, y
            call NOD ; (AX) = NOD(x, y)
        endm
    \end{minted}

    \begin{minted}{asm}
        call_nod A,B ; наглядное обращение к ПП с параметрами
        mov CX, AX ; (CX) = NOD(A, B)
        call_nod C,D ; (AX) = NOD(C, D)
        add CX, AX ; (CX) = NOD(A, B) + NOD(C, D)
    \end{minted}

    \textbf{Использование меток в макросах}
    Пример 1. Если в макроопределении используются метки, но нет директивы local, то после макрогенерации будет сообщение об ошибке - дублирование меток:
    \begin{minted}{asm}
        ; макроопределение
        M macro
            .......
            L:.....
        endm

        ; Макрокоманда
        .....
        M
        .....

        ; макрорасширение
        .....
        .....
        L: .....
        .....
        .....
    \end{minted}
\end{enumerate}

Вычислить остаток от деление одного числа на другое с помощью вычитание (числа натуральные, r1 и r2 - регистры)
\begin{minted}{asm}
    MD macro r1, r2 ; r1 = r1 mod r2
        local M, M1
        M: cmp r1, r2 ; while r1 >= r2 do r1 = r1 - r2
        jb M1
        sub r1, r2
        jmp M
        M1:
    endm
    ; обращение к макросу MD: (r1 = AX, r2 = BX)
    ; 1)
    MD AX, BX
    ??0000: cmp AX, BX
    jb ??0001
    sub AX, BX
    jmp ??0000
    ??0001: -------
    ; 2)  MD CX, BX ; (r1 = CX, r2 = DX)
    ----------
    ??0002: cmp CX, DX
    jb ??0003
    sub CX, DX
    jmp ??0002
    ??0003: -------
\end{minted}

Макрогенератор, встретив директиву local M, M1 будет заменять метки M и M1 на специальные имени вида ??хххх, где хххх - четырехзначное 16-ричное число от 0000/FFFF.
\subsection{Директивы условного ассемблирования (ДУА)}
ДУА управляют процессом ассемблирования путем подключения или отключения фрагментов исходного текста программы. Общий вид:
\begin{minted}{asm}
    ; 1)
    if <выражение>
        if-часть
    [else
        else-часть ]
    endif
    ; 2)
    if <выражение>
        if-часть
    elseif <выражение 1>
        elseif-часть 1
    elseif <выражение 2>
        elseif-часть 2
    --------------------
    [else
        else-часть ]
    endif
\end{minted}

Дуа в форме 2) используется аналогично операторам выбора в языках высокого уровня. ДУА много, рассмотрим некоторые из них:
\begin{enumerate}
    \item if <константое выражение> if-часть
    if-часть ассемблируется, включается в исходный текст программы, если значение выражения - истина, т.е. не равно нулю, в противном случае работает else-часть, если она есть, если else-части нет, выполняется следующий за директивой if оператор.
    \item а) ife <констаное выражение>
    в) elseife <константное выражение>
    if-часть работает, если выражение ложно, равно нулю.
    \item a) ifdef метка ; if-часть работает, если
    в) elseifdef метка ; указанная метка определена
    \item a) ifndef метка ; if-часть работает, если
    в) elseifndef ; указанная метка не определена
    \item a) ifb <аргумент> ; if-часть работает, если
    в) elseifb <аргумент> ; значением аргумента является пробел
    \item a) ifnb <аргумент> ; if-часть работает, если значением
    в) elseifnb <аргумент> ; аргумента является не пробел
    \item a) ifdif <аргумент 1>,<аргумент 2>
    в) elseifdif <аргумент1>,<аргумент 2> ; if-часть работает, если аргументы различны, прописные и строчные буквы различаются
    \item а) ifdifi <аргумент 1>,<аргумент 2>
    в) elseifdifi <аргумент 1>,<аргумент 2>
    if-часть работает, если аргументы различны, прописные и строчные буквы не различаются
    \item a) ifidn <аргумент 1>,<аргумент 2>
    в) ekseifidn <аргумент 1>,<аргумент 2>
    if-часть работает, если аргументы одинаковы, прописные и строчные буквы различаются
    \item a) ifidni <аргумент 1>,<аргумент 2>
    в) elseifidni <аргумент 1>,<аргумент 2>
    if-часть работает, если аргументы одинаковы, прописные и строчные буквы не различаются
    Здесь угловые скобки обязательны.
\end{enumerate}

\subsection{Примеры использования ДУА}
1) Использование ДУА непосредственно в Ассемблере. При отладке большой программы обычно используются отладочные печати для проверки правильности работы отдельных ее участков. В отлаженной программе эти печати удаляются. Но если отладка выполняется в несколько этапов, то добавлять печати в программу и исключать их -
это тоже громоздкая работа, во время которой можно внести новые ошибки.

Используя ДУА, задачу включения в исходный текст программы и исключения из нее отладочных печатей перекладываем на макрогенератор, а он не ошибается. Для этого программисту нужно определить константу, установив таким образом реэим отладки или счета. Например,
\begin{minted}{asm}
    debug equ 1 ; отладка
    debug equ 0 ; счет
    ; А в программе должно быть:
    mov x, AX
    if debug
        Outlnt x
    endif
    mov BX, 0
\end{minted}

После макрогенерации в программе появится текст, если debug <> 0:
\begin{minted}{asm}
    mov x, AX
    Outlnt x
    mov BX, 0
    ; если debug = 0:
    mov x, AX
    mov BX, 0
\end{minted}

Здесь Outlnt - макрокоманда обращения к процедуре вывода. Решить задачу, чтобы отладочная печать работала в режиме отладки и не работала при счете, можно и с помощью команды сравнения и условного перехода:
\begin{minted}{asm}
    mov x, AX
    mov CL, debug
    cmp CL, 1
    jne L
    Outlnt x
    L: mov BX, 0
\end{minted}

Однако, этот текст всегда будет занимать место в памяти и, если таких участков будет много, то исходный текст будет громоздким и время выполнения программы будет существенно больше. При использовании условной генерации время тратится только на этапе ассемблирования. При счете этих операций в исходном тексте не будет.

\subsection{Использование ДУА в макросах}

Пример 1. Опишем в виде макроса операцию сдвига значения переменной x на n разрядов вправо. Макрорасширение должно содержать минимально возможное число команд. Это можно сделать так6
\begin{minted}{asm}
    shift macro x,n
        ife n-1 ; n - 1 = 0 ?
            shr x, 1
        else ; n > 1
            mov CL, n
            shr x, CL
        endif
    endm
    ; Обращения:
    shift A, 5 ; x = A, n = 5
    ; после макрогенерации:
    mov CL, 5
    shr A, CL
\end{minted}

Пример 2. Констаное выражение в if и ife может быть любым, но так как оно вычисляется на этапе макрогенерации, в нем не должно быть ссылок на величины, которые станут известными только при выполнении программы. Например, в константных выражениях не должно быть ссылок на регистры и ячейки памяти, не должно быть ссылок вперед.
Константное выражение должно быть вычислено макрогенератором при первом проходе.

Констаное выражение часто бывает логическим, в нем могут использоваться операторы отношения: EQ, NE, LT, LE, GT, GE и логические операторы NOT, OR, XOR.

Запишем в виде макроса SET_0 x операцию х = 0, если х - переменная размером в байт, слово или двойное слово.
\begin{minted}{asm}
    SET_0 macro x
        if type x eq dword
            mov dword ptr x, 0
        elseif type x eq word
            mov word ptr x, 0
        else mov byte ptr x, 0
        endif
    endm
\end{minted}

Пример 3. Напишем еще одно макроопределение для сдвига вправо на n разрядов значения байтовой переменной B. Учтем, что при n = 0 сдвига нет и макрорасширение не должно появиться в тексте программы, а при n > 7 результат сдвига - это 0, поэтому сдвиг можно заменить записью нуля в В.
\begin{minted}{asm}
    SET_0 macro B, n
        if (n GT 0) AND (n LT 8) :: 0 < n < 8
            mov CL, n
            shr B, CL
        else
            if n GE 8 :: n >= 8
                mov B, 0
            endif
        endif
    endm
\end{minted}
Здесь использовались вложенные if...endif и в макроопределениях комментарий записывается после ;;

Пример 4. Использование ifidn и ifdif
Поиск max или min из двух знаковых величин, хранящихся в байтовых регистрах, т.е. вычислить R1 = T(R1, R2),
где T - это max или min, причем, должно генерироваться непустое макрорасширение только если R1 и R2 - это разные регистры. Если обращение к макросу будет Max_Min R1, R2, T, то необходимо проверять несовпадение первых двух параметров. И чтобы один макрос вычислял и max, и min, нужно проверять и значение третьего параметра. Макрос может быть таким:
\begin{minted}{asm}
    Max_Min macro R1,R2,T
        local L
        ifdif <R1>, <R2> ;; R1 и R2 - разные регистры
            cmp R1, R2
            ifidn <T>, <max> ;; T = max ?
                jge L
            else
                jle L
            endif
            mov R1, R2
        L: endif
    endm
\end{minted}

