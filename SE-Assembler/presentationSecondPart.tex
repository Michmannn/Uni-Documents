\section{Работа с программами}

Программа, оформленная как процедура, к которой обращение происходит из ОС, заканчивается командой возврата ret.

Подпрограмма, как вспомогательный алгоритм, к которому возможно многократное обращение с помощью команды call,
тоже оформляется как процедура с помощью директив proc и endp. Структуру процедуры можно оформить так:

\begin{minted}{asm}
    <имя процедуры> proc <параметр>
        <тело процедуры>
        ret
    <имя процедуры> endp
\end{minted}

В Ассемблере один тип подпрограмм - процедура. Размешать ее можно в любом месте программы, но так, чтобы управление на нее не попадало случайно, а только по команда call.
Поэтому описание ПП принято располагать в конце программного сегмента (после последней исполняемой команды), или вначале его - перед первой исполняемой командой.

\section{Графическое представление}

\begin{minted}{asm}
    1) cseg segment .....
    beg: ----------------
    ---------------------
    ---------------------
    fin: ----------------
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    2) cseg segment
    <подпрограмма 1>
    <подпрограмма 2>
    ---------------------
    <подпрограмма n>
    beg:-----------------
    ---------------------

    cseg ends
    end beg
\end{minted}

\begin{minted}{asm}
    3) cseg_pp segment
    <>
    cseg_pp ends
    cseg segment...
    ---------------------
    cseg ends
    end beg
\end{minted}

Если программа содержит большое количество подпрограмм, то ПП размещают в отдельном кодовом сегменте - вариант структуры 3).

\paragraph{Замечания:}

\begin{itemize}
    \item После имени в директивах proc и endp двоеточие не ставится, но имя считается меткой, адресом первой исполняемой процедуры.
    \item Метки, описанные в ПП, не локализируются в ней, поэтому они должны быть уникальными в рамках всей программы.
    \item Параметр в директиве начала процедуры один - FAR или NEAR.
\end{itemize}

Основной проблемой при работе с ПП является передача параметров и возврат результатов в вызывающую программу.
Существуют различные способы передачи параметров:
\begin{enumerate}
    \item по значению;
    \item по ссылке;
    \item по возращаемому значению;
    \item по результату;
    \item отложенным вычислением.
\end{enumerate}

Параметры можно передавать:
\begin{enumerate}
    \item через регистры;
    \item в глобальных переменных;
    \item через стек;
    \item в потоке кода;
    \item в блоке параметров.
\end{enumerate}

Передача параметров через регистры - наиболее простой способ. Вызывающая программа записывает в некоторые регистры фактические парамтеры...

\textbf{Примерами использования этого метода являются вызовы некоторых прерываний ОС и BIOS.}

Когда регистров не хватает, один из способов обойти это ограничение - записать параметр в глобальную переменную, к которой затем обращаться в ПП.
Но этот мето считается не эффективным, так как может оказаться невозможной рекурсия, и даже простое повторное обращение к ПП.

Передача параметров через стек. Перед обращением к процедуре фактические параметры (их значения или адреса) записываются в стек, а процедура их из стека извлекает.
Именно этот способ используют языки высокого уровня.

Передача параметров в потоке кода заключается в том, что данные, передаваемые в ПП, располагаются сразу за командой обращения к ПП call.
ПП, чтобы использовать эти данные, должна обратиться к ним по адресу, который записывается в стек автоматически как адрес возврата из ПП.
Но ПП в этом случае должна перед командой возврата изменить адрес возврата на адрес байта, следующий за передаваемыми параметрами. Этот метод реализует передачу
параметров медленнее, чем через регистры, глобальные переменные или стек, но примерно также, как и метод передачи параметров в блок параметров.

Блок параметров - это участок памяти, содержащий параметры и располагающийся обычно в сегменте данных.

Процедура получает адрес начала этого блока при помощи любого из рассмотренных методов: в регистре, в переменной, в стеке, в коде или даже в другом блоке параметров.
Примеры использования этого способа - многие функции ОС и BIOS, например, поиск файла, использующий блок параметров DTA, или загрущка и исполнение программы, использующая блок параметров EPB.

\subsection{Передача параметров по значению и по ссылке}

При передаче параметров по значению процедуры передается значение фактического параметра, оно копируется в ПП, и ПП использует копию, поэтому изменение, модификация параметра
оказывается невозможным. Этот механизм используется для передачи параметров небольшого размера.

Например, нужно вычислить \textbf{c = max(a, b) + max(7, a-1)}. Здесь все числа знаковые, размером в слово. Используем передачу параметров через регистры. Процедура получает параметры через
регистры. Процедура получает параметры через регистры AX и BX, результат возвращается в регистр AX.
Процедура:
\begin{minted}{asm}
    AX = max(AX, BX)
    max proc
        cmp AX, BX
        jge met1
        mov AX, BX
        met1: ret
    max endp
\end{minted}

\section{Фрагмент вызывающей программы:}
-----------------
\begin{minted}{asm}
    ; c = max(a, b) + max(7, a-1)
    mov AX, a
    mov BX, b
    call max ; AX = max(a, b)
    mov c, AX ; c = max(a, b)
    mov AX, 7
    mov BX, a
    dec BX
    call max ; AX = max(7, a-1)
    add c, AX
\end{minted}
-----------------

\section{Передача параметров по ссылке.}

Оформим как процедуру вычисление \textbf{x = x div 16}

Процедура имеет один параметр-переменную х, которой в теле процедуры присваивается новое значение. Т.е. результат записывается в некоторую ячейку памяти. И чтобы обратиться к процедуре с различными параметрами, например,
a и b, ей нужно передавать адреса памяти, где хранятся значения переменных a и b. Передавать адреса можно любым способом, в том числе и через регистры. Можно использовать различные регистры, но чаще используются BX, BP, SI, DI.
Пусть адрес параметра передается через регистр ВХ, тогда фрагмент программы:
\begin{minted}{asm}
    ; основная программа
    --------------------
    lea RBX, a
    call Proc_div
    lea BX, b
    call Proc_dv
\end{minted}

Процедура:
\begin{minted}{asm}
    Proc_dv proc
        push CX
        mov CL, 4
        shr word ptr [BX], CL ; x = x div 16
        pop CX
        ret
    Proc_dv endp
\end{minted}
Сдвиг на 4 разряда вправо эквивалентен делению нацело на 16 и выполняется быстрее.

Здесь первая команда в процедуре сохраняет в стеке значение регистра СХ, так как затем использует CL в команде сдвига и возможно этот регистр используется в основной программе.

Т.к. регистров немного а и ПП, и основная программа могут использовать одни и те же регистры, то при входе в ПП нужно сохранять в стеке значения регистров, которые будут использоваться в ПП, а перед выходом из нее восстанавливать значениях этих регистров.
Для поддержки  этого, начиная с ix186, в систему команд введены команды сохранения в стеке и извлечения из него сразу всех регистров общего назначения
\textbf{pusha} и \textbf{popa}, а, начиная с ix386, \textbf{pushad popad}.

Не нужно сохранять в стеке значение регистра, в который записывается результат работы ПП.

\section{Передача параметров по ссылке в блоке параметров}

Если параметров много, например, массив, адрес начала массива как блока параметров, можно передать через регистр, даже если результат ПП не будет записываться по этому адресу.

Даны два массива целых положительных чисел без знака
\begin{minted}{asm}
    X db 100 dup (?)
    Y db 50 dup (?)
\end{minted}

Вычислить DL = max(X[i]) + max(Y[i]), использовав процедуру max(A[i]), пересылая адрес массива через регистр ВХ, а результат сохраняя в AL.
\begin{minted}{asm}
    ; фрагмент программы
    lea BX, X
    mov CX, 100
    call max ; AL = max(X[i])
    mov DL, AL ; DL = max(X[i])
    lea BX, Y
    mov CX, 50
    call max
    add DL, AL
\end{minted}

Процедура max: AL = max(A[0..n-1]), BX - начальный адрес CX = n

\begin{minted}{asm}
    max proc
        push CX
        push BX
        mov AL, 0 ; начальное значение max
        met1:
        cmp [BX], AL
        jle met2
        mov AL, [BX]
        met2:
        inc BX
        loop met1
        pop BX
        pop CX
        ret
    max endp
\end{minted}

\section{Передача параметров в стек.}

Этот способ передачи параметров называют универсальным, его можно использовать при любом количестве параметров, хотя он сложнее, чем передача параметров через регистры.
Но для передачи результатов чаще используют регистры.

Если ПП имеет k параметров PP(a1, a2, ..., ak) размером в слово и параметры сохраняются в стеке в последовательности слева направо, то команды, реализующие обращение к ПП, должны быть следующими:

\begin{minted}{asm}
    ; обращение к процедуре PP
    push a1
    push a2
    ---------
    push ak
    call pp
    av:------
\end{minted}

содержимое стека при входе в pp
\begin{figure}
    \includegraphics{}
\end{figure}

Обращение к параметрам в процедуре можно осуществить с помощью регистра BP, присвоив ему значение SP.

Но при этом мы испортим старое значение BP, которое может быть используется в основной программе. Поэтому следует в начале сохранить старое значение ВР в стеке, а затем использовать его
для доступа к параметрам, т.е. тело процедуры долно начинаться следующими командами:
\begin{minted}{asm}
    PP proc near
        push BP
        mov BP, SP
        ----------
        ret
    PP endp
\end{minted}

в стеке после выполнения этих команд
\begin{figure}
    \includegraphics{}
\end{figure}

Для доступа к последнему параметру можно использовать выражение [BP + 4], например, mov AX, [BP + 4] ; ak -> AX
После "входных действий" в ПП идут команды, реализующие вспомогательный алгоритм, а за ними д.б. команды, реализующие "выходные действия":

\begin{minted}{asm}
    PP proc near
        push BP
        mov BP, SP
        ----------
        pop BP
        ret 2 * k
    PP endp
\end{minted}

n в команде \textbf{ret n} - это количество освобождаемых байтов в стеке, поэтому количество параметров д.б. умножено на длину параметра...
Команда ret вначале считывает значение av, а затем удаляет из стека параметры. Очистку стека можно выполнять не в ПП, а после выхода из нее, в основной программе, сразу после команды call PP, например, командой \textbf{add SP, 2 * k}

Каждый способ имеет свои достоинства и недостатки, если в ПП, то исполняемый код будет короче, если в основной программе, то можно вызвать ПП несколько раз с одними и теме же параметрами последовательными командами \textbf{call...}

Для удобства использования параметров, переданных через стек, внутри ПП можно использовать директиву equ, чтобы при каждом обращении к параметрам не писать точное смещение относительно BP.

\begin{minted}{asm}
    push x
    push y
    push z
    call PP
    ---------

    PP proc near
        push BP
        mov BP, SP
        pp_x equ [BP+8]
        pp_y equ [BP+6]
        pp_z equ [BP+4]
        ---------------
        mov AX, pp_x
        ---------------
        pop BP
        ret 6
    PP endp
\end{minted}

\section{Пример передачи параметров через стек.}

Пусть процедура заполняет нулями массив A[0..n-1], основная программа обращается к ней для обнуления массивов X[0..99] и Y[0..49]. Через стек в ПП передается имя массива и его размер, размер можно передавать по значению,
а имя массива нужно передавать по ссылке, т.к. этот параметр является и входным, и выходным.
\begin{minted}{asm}
    ; процедура zero_1
    zero_1 proc
        push BP ; входные
        mov BP, SP ; действия
        push BX ; сохранение значений
        push CX ; регистров
        mov CX, [BP+4] ; СХ = n считывание из стека
        mov BX, [BP+6] ; ВХ = А параметров
        m1:
        mov byte ptr [BX], 0 ; цикл обнуления
        inc BX ; массива
        loop m1 ; A[0..n-1]
        ; восстановление регистров и выходные действия
        pop CX
        pop BX
        pop BP
        ret 4
    zero_1 endp

    Фрагмент основной программы:
    X db 100 dup (?)
    Y db 50 dup (?)
    ---------------
    lea AX, X ; загрузка параметров:
    push AX ; адреса массива Х
    mov AX, 100 ; и его размера
    push AX ; в стек
    call zero_1 ; обращение к ПП
    lea AX, y ; загрузка параметров для массива Y
    push AX
    mov AX, 50
    push AX
    call zero_1 ; обращение к ПП
    ----------------
\end{minted}

\section{О передаче параметров в ПП}
\begin{enumerate}
    \item Передача по значение 
    \begin{minted}{asm}
        mov AX, word ptr value
        call PP
    \end{minted}
    \item Передача по ссылке
    \begin{minted}{asm}
        mov AX, offset value
        call PP
    \end{minted}
    \item Передача аргументов по возвращаемому значению объединяет передачу по значению и по ссылке: процедуре передается адрес переменной, она делает локальную копию этого параметра, работает с этой копией, а в конце процедуры записывает эту копию по переданному адресу. Этот механизм оказывается эффективным, если процедуре приходиться много раз обращаться к параметру в глобальной переменной.
    \item Передача параметров по результату заключается в том, что в ПП передается адрес только для записи по этому адресу результата работы ПП.
    \item Передача параметров по имени макроопределения. Пример:
    \begin{minted}{asm}
        name macro parametr
            mov AX, parametr
        name endm
    \end{minted}
    Обращение к ПП может быть таким:
    \begin{minted}{asm}
        name value ; обращение к макро
        call PP ; обращение к ПП
    \end{minted}
    \item Передача параметров отложенным вычислением. Как и в случае передачи параметров по имени, процедура получает адрес ПП, вычисляющей значение параметра. Этот механизм чаще используется в системах искусственного интеллекта и в ОС.
\end{enumerate}

\section{Использование локальных параметров.}

Если локальных параметров несколько, то их размещают в регистрах, но если их много, то возможны различные варианты: им можно отвести место в сегменте данных, но тогда большую часть времени эта область памяти не будет использоваться.
Лучший способ - разместить локальные параметры в стеке на время работы ПП, а перед выходом из ПП их удалить. Для этого после входных действий в процедуре нужно уменьшить значение указателя на вершину стека SP на количество байтов, необходимых для хранений локальных величин и затем записывать их в стек и извлекать их можно с помощью выражений вида: [BP - n], где n определяет смещение локального параметра относительно значения BP.

Например, если предполагается, что ПП будет использовать 3 локальных параметра размером в слово, то стек графически можно представить так:
\begin{figure}
    \includegraphics{}
\end{figure}
При выходе из процедуры перед выполнением завершающих действий нужно возвратить регистру SP его значение.

Если в стеке хранятся и фактические, и локальные параметры, то начало процедуры и ее завершение должны выглядеть следующим образом:
\begin{minted}{asm}
    PP proc
        push BP ; сохранить старое значение ВР
        mov BP, SP ; кладём SP в ВР
        sub SP, k1 ; отвести в стеке k1 байтов под локальные параметры
        push AX
        --------------
        <тело процедуры>
        --------------
        pop AX
        mov SP, BP ; восстановить SP, т.е. освободить место
                ; в стеке от локальных параметров
        pop BP ; восстановить ВР, равным до обращения к ПП
        ret k2 ; очистка стека от фактических параметров и возврат в вызывающую программу
    PP endp
\end{minted}

\section{Подсчет количества различных символов в заданной строке.}

Строка задана как массив символов. Начальный адрес ее передадим в ПП через регистр BX, длину строки через СХ, а результат - через АХ. Создадим процедуру, в которой выделяется 256-ый локальный массив L по количеству возможных символов.
К-ому элементу этого массива будем присваивать единицу, если символ, цифровой код которого равен К, в заданной строке существует. Затем подсчитаем количество единиц в этом массиве. Вначале весь массив обнуляется.
К первому элементу этого массива можно обратиться так: \textbf{L1 = [BP-256] к К-ому Lk = [BP-256 + k]}
Работая со строками, эту задачу можно решить проще.
\begin{minted}{asm}
    Count_s proc ; входные действия
        push BP
        mov BP, SP
        sub SP, 256
        push BX
        push CX
        push SI
\end{minted}