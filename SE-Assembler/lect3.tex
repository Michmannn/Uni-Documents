\subsection{Примеры команд с различным способом адресации}

\begin{enumerate}
    \item Регистровая.
    \verb|mov AX, BX|
    \item Непосредственная.
    \verb|mov AX, 25|
    Кроме того, можно передать именованную константу с помощью конструкции \verb|const EQU 34h|
    \item Прямая. Если известен адрес в памяти, то в команде можно непосредственно передать этот адрес:
    \verb|mov AX, ES : 0001|, где ES "--- регистр сегмента данных, 0001 "--- смещение внутри сегмента. В таком случае
    содержимое двух байтов, начиная с адреса (ES) + 0001 пересылаются в AX
    ((ES) + 0001) -> AX

    Прямая адресация может быть записана с помощью символического имени, если этому имени
    предварительно поставить в соответствие некоторый адрес в оперативной памяти, а сделать
    это можно с помощью специальной директивы "--- директивы определения данных и памяти.
    
    DB "--- define byte
    DW "--- define word
    DD "--- define double word
    
    Если в сегменте ES содержится директива Var_p DW ?, тогда передадим по команде

    \verb|mov AX, ES: Var_p; ((ES) + Var_p) -> AX|
    \item Косвенно"=регистровая
    
    Данный вид адресации отличается от регистровой адресации тем, что в регистре содержится
    не сам операнд, а адрес области памяти, в которйо операнд содержится.
    
    \verb|mov AX,[SI]|
    
    Нельзя использовать AX, CX, DX, SP, ESP, остальные регистры допустимы.
    
    \item По базе со смещением

    \verb|mov AX, [BX] + 2; ((DS) + BX + 2)->AX|

    \verb|mov AX, [BP] + 4; ((SS) + (BP) + 4)->AX|
    
    \item Прямая с индексированием
    
    \verb|mov AX, MAS[SI]; ((DS) + (SI) + MAS)->AX|

    Эту адресацию используют с полями структуры. С двумерными массивами можно работать с адресацией по базе с индексированием.
    
    \item По базе с индексированием
    
    \verb|mov AX,Arr[BX][DI]; ((DS) + (BX) + (DI) + Arr)->AX|

    \item По базе с масштабированием
    
    \verb|MOVAX, [EBX*4]+2; Только для 32-х разрядных операндов|

Символическое имя определяет начало массива, с помощью базового регистра осуществляется
переход от одной строки к другой. Кроме того, используется при массивах структур.
   
\end{enumerate}

Особенности работы команд пересылки:
\begin{itemize}
    \item Нельзя пересылать из одной памяти в другую
    \item Нельзя пересылать информацию из одного сегментного регистра в другой.
    Если есть такая необходимость нужно воспользоваться регистром общего назначения или стеком
    для промежуточной пересылки.
    \item Нельзя пересылать непосредственный операнд в сегментный регистр. Если же такая
    необходимость есть "--- использовать регистр общего назначения.
    \item Нельзя командой mov изменять содержимое регистра CS.
    \item Данные в памяти хранятся в перевернутом виде, а в регистрах в нормальном
    виде, команда mov это учитывает.
    Например, R DW 1234h. Тогда в байте с адресом R будет 34h, а в байте R + 1 12h.
    Обратная картина в AH и AL при выполнении mov AX, R.
    \item Размер передаваемых данных определяется типом операнда.
    Например, пусть \verb|X DB ?, Y DW ?|, тогда при выполнении \verb|mov X, 0| в один байт запишется
    ноль, а если \verb|mov Y, 0| "--- два байта вместо одного.

    \verb|mov [SI], 0| "--- сообщение об ошибке. Чтобы этого не случилось, нужно определить
    тип операнда с помощью оператора PTR:

    \verb|<ТИП> PTR <ВЫРАЖЕНИЕ>|

    Выражение может быть как константным, так и адресным, а тип это: BYTE, WORD, DWORD и т.д.

    Например: \verb|mov Byte PTR[SI], 0| или \verb|mov [SI], byte PTR 0|.
    \item Если тип обоих операндов определен, известен, то эти типы должны соответствовать друг@=другу.
\end{itemize}

К командам пересылки относится команда \verb|xchg|. Операндами могут быть регистр"=регистр, регистр"=память.
Для перестановки значений байтов внутри регистра используют \verb|BSWOP|.

Также существуют команды конвертирования: \verb|CRW, CWD, CWE, CDF| (последние две для x386 и выше).

Есть команды условной пересылки: \verb|CMOVxx|.

Команда загрузки адреса: \verb|LEA OP1, OP2| "--- вычисляет адрес OP2 и пересылает первому операнду,
который может быть только регистром.

\subsection{Структура программы на ассемблере}

Программа на ассемблере должна пройти три этапа обработки.

На первом этапе, в процессе ассемблирования, исходный модуль преобразуется в машинный
код, таким образом получается объектный модуль исходных модулей и объектов может быть
несколько.

На втором этапе с помощью редактора связей (компоновщика) объектные модули преобразуются
в исполняемый модуль (\verb|.exe|, \verb|.com|). Для получения com"=файла нужно выполнить ещё один
этап обработки с помощью системной обрабатывающей программы. Для получения \verb|.com| файла
из \verb|.exe| файла нужно, чтобы исходный модуль удовлетворял определенным требованиям.

Исходный файл на ассемблере состоит из команд, директив и комментариев. Команды
в процессе ассемблирования преобразуются в программы на машинном языке, определяющим
этапы решения задачи. Директивы определяют форматы данных (исходных, промежуточных, окончательных)
и их размещение в памяти, а также определяют как программа должна быть транслирована ассемблером.

Команда в ассемблере в общем виде состоит из четырех полей:

\verb|[<имя>][:]<код операции>[<операнды>][комментарий]|

В скобках располагаются необязательные поля. Имя "--- символическое имя ассемблера, которое
используется как метка команды, на которую можно передать управление. Если после
имени стоит двоеточие, то такая метка называется внутренней и на нее можно передать
управление только из сегмента, в котором эта команда содержится.

Операнды отделяются друг от друга запятой, все поля отделяются друг от друга хотя бы
одним пробелом, а перед комментарием ещё записывается точка с запятой. Комментарий
может занимать часть строки или всю строку.
Например, \verb|JMP M1| "--- команда передачи управления на команду с меткой M1.

Директива, как и команда, состоит из четырех полей:

\verb|[<имя>]<код псевдооперации> <операнды> [; комментарий].|

Код псевдооперации  назначение директивы.
Операндов может быть различное количество в одной директиве.

\verb|M1 DB 1, 0, 1, 0, 1| "--- выделение пяти байтов подряд.

Proc "--- директива начала процедуры, endp "--- конца.

Исходный модуль на ассемблере состоит из последовательности строк, команд, директив и комментариев
и при ассемблировании текст просматривается сверху вниз слева направа от начала, пока
не увидит директиву end, которая и символизирует конец исходного текста программу.
Обычно программа состоит из трех сегментов. 

\begin{minted}{asm}
    Sseg Segment
    ...
    Sseg ends
    DSeg Segment
    ...
    DSeg ends
    CSeg Segment
    ...
    Cseg ends
    end start
\end{minted}

Каждый сегмент начинается с директивы Segment и заканчивается директивой ends. Параметры
директивы Segment говорят о назначении сегмента. Кроме того, в кодовом сегменте сразу
после директивы Segment должна располагаться директива, устанавливающая соответствие
между именами в директивах Segment и сегментными регистрами "--- \verb|assume|.

\begin{minted}{asm}
    assume SS :SSeg, CS: CSeg, DS: Dseg, ES: Dseg
\end{minted}

Кодовый сегмент выглядит как процедура, это может быть одна процедура или последовательность
процедур.

Структура кодового сегмента с использованием двух вложенных процедур выглядит следующим
образом:

\begin{minted}{asm}
    Cseg segment...
    assume...

    pr2 Proc
    ...
    pr2 ends

    pr1 Proc
    ...
    pr2
    pr1 ends

    end pr1
\end{minted}

В сегменте стека выделяется место под стек.
В сегменте данных определяются данные, используемые в программе, выделяется место
под промежуточные и окончательные результаты.
Кодовый сегмент содержит программу решения поставленной задачи.

\begin{minted}{asm}
    ;Prim1.asm
    ;Сегмент стека
    Sseg segment
        db 256 dup(?)
    Sseg ends
    ;Сегмент данных
    Dseg segment
        X db 'A'
        Y db 'B'
        Z db 'C'
    Dseg ends
    Cseg segment
        assume SS:Sseg, DS:DSeg, CS:Cseg
        start proc FAR
        push DS
        push AX
        mov DS, Dseg
        mov DS, DX
        call Main
        ret
    Start endp
    main proc NEAR
        add AL, X
        mov AX, Y
        ...
        ret
    main endp
    Cseg ends
    end start
\end{minted}

Наш кодовый сегмент представлен в виде двух последовательных процедур: первая из них
внешняя, об этом говорит параметр \verb|far| директивы \verb|Proc|, она реализует связь с операционной системой.
\verb|near| же говорит о том, что процедура внутренняя.

К внешней процедуре можно обратиться из любого кодового сегмента, к внутренней можно обратиться
только из того сегмента, в котором содержится её определение.
