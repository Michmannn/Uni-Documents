\subsection{Примеры команд с различным способом адресации}

\begin{enumerate}
    \item Регистровая:
    $mov AX, BX$
    \item Непосредственная:
    $mov AX, 25$
    Кроме того, можно передать именованную константу с помощью конструкции $const EQU 34h$
    \item Прямая:
    Если известен адрес в памяти, то в команде можно непосредственно передать этот адрес:
    $mov AX, ES : 0001$.
    ES "--- регистр сегмента данных, 0001 "---- смещение внутри сегмента. В таком случае
    содержимое двух байтов, начиная с адреса (ES) + 0001 пересылаются в AX
    ((ES) + 0001) -> AX

    Прямая адресация может быть записана с помощью символического имени, если этому имени
    предварительно поставить в соответствие некоторый адрес в оперативной памяти, а сделать
    это можно с помощью специальной директивы "--- директивы определения данных и памяти.
    
    DB "--- define byte
    DW "--- define word
    DD "--- define double word
    
    Если в сегменте ES содержится директива Var_p DW ?, тогда передадим по команде

    $MOV AX, ES: Var_p : ((ES) + Var_p) -> AX$
    
    Если команда имеет вид
    
    $MOV AX, Var_p; ((DS) + Var_p) -> AX$
    \item Косвенно регистровая
    
    Данный вид адресации отличается от регистровой адресации тем, что в регистре содержится
    не сам операнд, а адрес области памяти, в которйо операнд содержится.
    
    $mov AX,[S]$
    
    Нельзя использовать AX, CX, DX, SP, ESP.
    
    \item По базе со смещением
    
    mov AX, [BX] + 2; ((DS) + BX + 2)->AX
    
    mov AX, [BP] + 4; ((SS) + (BP) + 4)->AX
    
    \item Прямая с индексированием
    
    mov AX, MAS[SI]; ((DS) + (SI) + MAS) ->AX

    Эту адресацию используют с полями структуры. С двумерными массивами можно работать с адресацией по базе с индексированием.
    
    \item По базе с индексированием
    
    $mov AX,Arr[BX][DI]; ((DS) + (BX) + (DI) + Arr)->AX$

Символическое имя определяет начало массива, с помощью базового регистра осуществляется
переход от одной строки к другой. Кроме того, используется при массивах структур.
    
    
\end{enumerate}

\begin{itemize}
    \item Нельзя пересылать из одной памяти в другую
    \item Нельзя пересылать информацию из одного сегментного регистра в другой.
    Если есть такая необходимость нужно воспользоваться регистром общего назначения или стеком
    для промежуточной пересылки.
    \item Нельзя пересылать непосредственный операнд в сегментный регистр. Если же такая
    необходимость есть "--- использовать регистр общего назначения.
    mov DX, 100h
    mov DS, DX
    \item Нельзя командой mov изменять содержимое регистра CS.
    \item Данные в памяти хранятся в перевернутом виде, а в регистрах в нормальном
    виде, команда mov это учитывает.

    Например, R DW 1234h. Тогда в байте с адресом R будет 34h, а в байте R + 1 12h.
    
    Обратная картина в AH и AL при выполнении mov AX, R.
    \item Размер передаваемых данных определяется типом операнда.
    
    Например, пусть X DB ?, Y DW ?, тогда при выполнении mov X, 0 в один байт запишется
    ноль, а если mov Y, 0 "--- два байта вместо одного.

    mov [SI], 0 "--- сообщение об ошибке. Чтобы этого не случилось, нужно определить
    тип операнда с помощью оператора PTR:

    <ТИП> PTR <ВЫРАЖЕНИЕ>

    Выражение может быть как константным, так и адресным, а тип это: BYTE, WORD, DWORD и т.д.

    Например: mov Byte PTR[SI], 0 или mov [SI], byte PTR 0.
    \item Если тип обоих операндов определен, известен, то эти типы должны соответствовать друг@=другу.
\end{itemize}

К командам пересылки относится команда xchg. Операндами могут быть регистр-регистр, регистр-память.
Для перестановки значений байтов внутри регистра используют BSWOP.

Также существуют команды конвертирования: CRW, CWD, CWE, CDF (последние две для x386 и выше).

Есть команды условной пересылки: CMOVxx.

Команда загрузки адреса: LEA OP1, OP2 "--- вычисляет адрес OP2 и пересылает первому операнду,
который может быть только регистром.

\subsection{Структура программы на ассемблере}

Программа на ассемблере должна пройти три этапа обработки.

На первом этапе, в процессе ассемблирования, исходный модуль преобразуется в машинный
код, таким образом получается объектный модуль исходных модулей и объектов может быть
несколько.

На втором этапе с помощью редактора связей (компоновщика) объектные модули преобразуются
в исполняемый модуль (.exe, .com). Для получения com"=файла нужно выполнить ещё один
этап обработки с помощью системной обрабатывающей программы. Для получения .com файла
из .exe файла нужно, чтобы исходный модуль удовлетворял определенным требованиям.

Исходный файл на ассемблере состоит из команд, директив и комментариев. Команды
в процессе ассемблирования преобразуются в программы на машинном языке, определяющим
этапы решения задачи. Директивы определяют форматы данных (исходных, промежуточных, окончательных)
и их размещение в памяти, а также определяют как программа должна быть транслирована ассемблером.

Команда в ассемблере в общем виде состоит из четырех полей:
[<имя>][:]<код операции>[<операнды>][комментарий]

В скобках располагаются необязательные поля. Имя - символическое имя ассемблера, которое
используется как метка команды, на которую можно передать управление. Если после
имени стоит двоеточие, то такая метка называется внутренней и на нее можно передать
управление только из сегмента, в котором эта команда содержится.

Операнды отделяются друг от друга запятой, все поля отделяются друг от друга хотя бы
одним пробелом, а перед комментарием ещё записывается точка с запятой. Комментарий
может занимать часть строки или всю строку.
Например, JMP M1 "--- команда передачи управления на команду с меткой M1.

Директива, как и команда, состоит из четырех полей:
[<имя>]<код псевдооперации> <операнды> [; комментарий].

Код псевдооперации  назначение директивы.
Операндов может быть различное количество в одной директиве.

M1 DB 1, 0, 1, 0, 1 "--- выделение пяти байтов подряд.

Proc "--- директива начала процедуры, endp "--- конца.

Исходный модуль на ассемблере состоит из последовательности строк, команд, директив и комментариев
и при ассемблировании текст просматривается сверху вниз слева направа от начала, пока
не увидит директиву end, которая и символизирует конец исходного текста программу.
Обычно программа состоит из трех сегментов. 

\begin{minted}{asm}
    Sseg Segment
    \dots
    Sseg ends
    DSeg Segment
    \dots
    DSeg ends
    CSeg Segment
    \dots
    Cseg ends
    end start
\end{minted}{asm}

Каждый сегмент начинается с директивы Segment и заканчивается директивой ends. Параметры
директивы Segment говорят о назначении сегмента. Кроме того, в кодовом сегменте сразу
после директивы Segment должна располагаться директива, устанавливающая соответствие
между именами в директивах Segment и сегментными регистрами "--- ASSUME.

\begin{minted}{asm}
    ASSUME SS :SSeg, CS: CSeg, DS: Dseg, ES: Dseg
    
\end{minted}

Кодовый сегмент выглядит как процедура, это может быть одна процедура или последовательность
процедур.

Структура кодового сегмента с использованием двух вложенных процедур выглядит следующим
образом:

\begin{minted}{asm}
    Cseg Segment\dots
    ASSUME\dots

    pr2 Proc
    \dots
    pr2 ends

    pr1 Proc
    \dots
    pr2
    pr1 ends

    end pr1
\end{minted}

В сегменте стека выделяется место под стек.
В сегменте данных определяются данные, используемые в программе, выделяется место
под промежуточные и окончательные результаты.
Кодовый сегмент содержит программу решения поставленной задачи.

\begin{minted}{asm}
    ;Prim1.asm
    ;Сегмент стека
    Sseg Segment
        DB 256 DUP(?)
    Sseg ends
    ;Сегмент данных
    Dseg Segment
        X DB 'A'
        Y DB 'B'
        Z DB 'C'
    Dseg ends
    Cseg Segment
        ASSUME SS:Sseg, DS:DSeg, CS:Cseg
        Start Proc FAR
        Push DS
        Push AX
        mov DS, Dseg
        mov DS, DX
        call Main
        Ret
    Start endp
    Main proc NEAR
        ADD AL, X
        MOV AX, Y
        \dots
        Ret
    Main endp
    Cseg ends
    end Start
\end{minted}

Наш кодовый сегмент представлен в виде двух последовательных процедур: первая из них
внешняя, об этом говорит FAR директивы Proc, она реализует связь с операционной системой.

Near говорит о том, что процедура внутренняя.

К внешней процедуре можно обратиться из любого кодового сегмента, к внутренней можно обратиться
только из того сегмента, в котором содержится её определение.
