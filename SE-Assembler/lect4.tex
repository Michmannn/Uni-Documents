Программа на ассемблере может работать с целыми двоичными, десятичными, шестнадцатиричными, действительными
с плавающей точкой числами, символами и строками. Сигнатура двоичных чисел имеет вид <<xxxxb>>.

Десятичная константа записывается как обычное число, а шестнадцатиричная содержать <<h>> на конце,
если же ведущая цифра это А, B, C, D, E, F, то в начале необходимо поставить 0.

Двоичные числа имеют вид мантисса"=порядок. 

Пример: 34,751e+02. 

Строковые константы "--- последовательности символов,
заключенных апострофами или двойными кавычками.

Как и в языках высокого уровня, на ассемблере могут быть именованные или неименованные константы.
Примеры неименованных были рассмотрены выше, их тип и значение определяются внешним видом на этапе компиляции.
Именованные константы создает программист с помощью специальной директивы EQU. Пример: M EQU 27.
Символическому имени M присваивается константное значение 27.

Переменные в ассемблере определяются с помощью директивы определения данных и памяти: v1 DR ?
v2 DW 34 или с помощью знака равенства: v3 = 100. 
Константы обычно используются как непосредственный операнд и в директивах определения данных и памяти.

Выражения в ассемблере строятся из операндов, операторов и скобок. Операнды "--- константы и переменные,
операторы "--- знаки арифметических, логический, специальных операций, а также операций отношения.
Все арифметические, логические операции и операции отношения характерны и другим языкам. Среди специальных
операций выделяют offset и PTR. offset возвращает смещение переменной относительно начала сегмента.
PTR определяет один из следующих типов для операнда:
\begin{itemize}
    \item BYTE
    \item WORD
    \item DWORD
    \item FWORD
    \item QWORD
    \item TWORD  
\end{itemize}
Кроме того, к специальным операциям относят \verb|near| и \verb|far|.

\subsubsection{Директива определения.} 
Её синтаксис следующий:

\verb|[<имя>] D{X} <операнды>[<;комментарий>], где X "--- B, W, D, F, Q, T.|

Имя определяет адрес первого байта выделенного поля (если оно есть), операндом может быть знак вопроса
или константа. Если это константа, то она записывается в выделенное поле, если знак вопроса, то в выделенное поле не записывается ничего.

Если операндом является символоическое имя (пусть это будет \verb|IM1|), которому предварительно поставлено
в соответствие некоторое значение, например, \verb|03AC1h|, то после выполнения
\verb|M DD IM1| будет выделено 4 байта памяти, в которое запишется значение \verb|03AC1h|.

Для выделения большого количества памяти используются директива \verb|dup|, например \verb|D db 100 dup (1)|.
Аналогично определяется, например, одномерный массив слов, например \verb|mas dw 1, 7, 35, 75, 84|.
У двумерного массива хранится указатель на элемент нулевой строки, нулевого столбца.

\begin{minted}{asm}
    const EQU 100
    d db const dup (?)    
\end{minted}


C помощью директивы определения байта возможно определить константу максимальной допустимой величины 255, для слова "--- 65535.

С помощью директивы определения байта можно определить строковую константу до 255 символов

Команда прерывания.

Команда прерывания приостанавливает выполнение программы и передает выполнение операционной системе
или BIOS в зависимости от операнда этой команды, после чего выполняется системная обрабатывающая программа
и управление возвращается к следующей за ним. А какая системная обрабатывающая программа будет выполняться
зависит от содержимого некоторых регистров. Например: чтобы вывести на экран символ, нужно выполнить три команды:
\begin{minted}{asm}
    mov AH, 6
    mov DL, "!"
    int 21h    
\end{minted}
Стек определяется регистрами SS и SP(ESP).
Начало сегмента стека записывается в регистр SS автоматически, 
а указатель на вершину стека при добавлении элемента уменьшается на размер операнда, при удалении
"--- увеличивается. Чтобы добавить элемент в стек нужно вызвать функцию push, чтобы удалить "--- pop.

Для i186 существуют команды \verb|pusha| И \verb|popa|, которые позволяют загрузить и удалить последовательность регистров
AX, BX, DX, CX, SP, BP, SL, DL. С i386 есть команды pushad и popad "--- аналогичные команды для extended версий
регистров.

\begin{minted}{asm}
TITLE Pris.asm; заголовок листинга
Page, 120; длина
SSeg Segment Para stack 'stack'
DB 100h
SSeg ends

DSeg Segment Para Public 'Data'
DAN DB '1', '3', '5', '7'
REZ DB 4 DUP (?)
DSeg ends
;кодовый сегмент оформлен как одна внешняя процедура, к ней обращаются из отладчика

CSeg Segment Para Public 'Code'
ASSUME SS:SSeg, DS:DSeg, CS:CSeg; соответствие между сегментными регистрами и именами
start proc Far
push DSeg
xor AX, AX
push AX
mov AX, DSeg
mov DS,AX
mov AH, 6
mov DL, DAN + 3
mov REZ, DL
int 21h
mov DL, DAN + 2
mov REZ + 1, DL
int 21h
mov DL, DAN + 1
mov REZ + 2, DL
int 21h
mov DL, DAN
mov REZ + 3, DL
int 21h

mov AH, 4CH
int 21h
Start endp
CSeg ends
end Start
\end{minted}


\subsubsection{Директива сегмента.}

Общий вид:

\verb|<имя> Segment <ReadOnly> <Выравнивание> <тип> <размер> <'класс'>|.

\verb|ReadOnly| устанавливает режим только для чтения для этого сегмента.

Операнд <<выравнивание>> устанавливает адрес начала сегмента:
\verb|BYTE, WORD, DWORD| "--- кратность байту, двум или четырем соответственно.

\verb|Para| "--- кратность шестнадцати. \verb|Page| "--- кратность 256.

<<Тип>> определяет тип объединения сегментов. Для стека устанавливается stack, для остальных сегментов public.
Если этот параметр присутствует, то все сегменты с одним именем и различными кклассами объединяются в один
последовательно в порядке их записи.

Значение 'Common' говорит, что сегменты с одним именем объединены, но не последовательно, а с одного и того же
адреса так, что общий размер сегмента равен не сумме, а максимальному из них.

Значение \verb|IT <выражение>| означает, что сегмент должен быть расположен по абсолютному адресу, определяемым выражением.
'Private' говорит о том, что этот сегмент не объединяется ни с каким другим.

Параметр размер может принимать значения \verb|use 16|, \verb|use 32|.
\subsubsection{Точечные директивы.}

В программе на ассемблере могут использоваться точечные директивы:
.MODEL "--- директива, определяющая модель выделяемой памяти для программы.
МОдель памяти определяется параметром:
tiny "--- под всю программу выделяется 1 сегмент памяти.
small "--- под данный и под программу выделяются по одному сегменту.
medium "--- под данные выделяется один сегмент, под программу выделяется несколько сегментов.
compact "--- под программу выделяется один сегмент, под данные выделяется несколько сегментов.
large "--- под данные и под программу выделяются по n элементов.
huge "--- позволяет использовать сегментов больше, чем позволяет оперативная память.

\begin{minted}{asm}
    .model small
    .stack 100h
    .data 
    \dots
    .code
    begin:
    mov AX, @data
    mov ds, AX
    mov AH, 9
    mov DX, offset St1
    int 21h
    аналогично для остальных двух
    mov AH, 4CH
    int 21
    end begin    
\end{minted}

\subsubsection{COM"=файлы}

Результатом ассемблирования и редактора"=компоновщника является исполняемый exe"=файл, которые содержит в себе,
так называемый, блок начала загрузки размером в 512 байт.

Но ассемблер позволяет создать другой тип исполняемых
файлов \verb|.com|, который может быть получен на основе \verb|.exe| файла в результате его обработки системной программой
\verb|EXE2bin.com| или с помощью специального ключа в среде разработки. 
Не из всякого EXE"=файла можно создать
COM"=файл "--- исходный файл должен удовлетворять определенным требованиям.

\paragraph{Основные отличия}
\begin{itemize}
    \item COM"=файл не содержит блока начальной загрузки(512 байт)
    \item EXE"=файл занимает произвольный объем ОП, COM"=файл только один сегмент памяти.
    \item в COM"=файле стек создается автоматически ОС, поэтому у пользователя нет необходимости выделять для него место.
    \item В COM"=файле данные располагаются там же, где и программа. Т.к вся программа содержится в одном сегменте, все сегментые регистры содержать
    в качестве значения адрес префикса программного сегмента (psp). И т.к PSP содержит 256 байт, то ддя обхода этого блока применяется org 100h.
\end{itemize})

\subsubsection{Арифметические операции}

\paragraph{Сложение и вычитание}
Сложение(вычитание) беззнаковых чисел выполняется по правилам аналогичным сложению (вычитанию)
по модулю $2^k$, принятым в математике. Если в результате более $k$ разрядов, то $k+1$"=ый пересылается
в \verb|CF|.

То есть:
\begin{equation*}
    \begin{cases}
        X + Y = (X + Y) \text{mod} ~2^k = X + Y, ~\text{CF} = 0 & \text{если $X + Y < 2^k$} \\
        X + Y = (X + Y) \text{mod} ~2^k = X + Y, ~\text{CF} = 1 & \text{если $X + Y \ge 2^k$} \\

    \end{cases}    
\end{equation*}

Пример:
\begin{equation*}
    250 + 10 = (250 + 10) ~\text{mod}~ 2^8 = 260~ \text{mod} ~256 = 4
\end{equation*}

Сложение (вычитание) знаковых чисел сводится к сложению (вычитанию) с использованием дополнительного кода.

Например, $-1 = 256 - 1 = 255 = {11111111}_2$, $-3 = 256 - 3 = 253 = {11111101}_2$
\begin{equation*}
    3 - 1 = 3 + (-1) = (3 + (-1))~\text{mod}~256 = (3 + 255)~ \text{mod}~256 = 2
\end{equation*}

Ответ получили в дополнительном коде, следовательно результат получаем  в байте по формуле $X = 10^8 - |X|$, т.~е.
$X = 256 - 254 = |2|$ и знак минус. Ответ: -2.

Переполнение разрядной сетки происходит если есть перенос из старшего цифрового в знаковый, а из знакового нет, и
наоборот, тогда OF = 1. Программист сам решает какой флажок анализировать "--- OF или CF, зная 
с какими данными он работает.

\paragraph{Сложение и вычитание в Ассемблере}

Арифметические операции изменяют значение флажков OF, CF, SF, ZF, AF, IF.

В Ассемблере операция сложения представлена несколькими командами.

\begin{minted}{asm}
    add OP1, OP2; (OP1) + (OP2) -> OP1
    adc OP1, OP2; (OP1) + (OP2) + (CF) -> OP1
    xadd OP1, OP2; (OP1)<->(OP2), (OP1) + (OP2) -> OP1
    inc OP1; OP1 + 1 -> OP1
\end{minted}

Аналогично работают команды sub, sbb, dec. В командах сложения (вычитания) можно использовать любые способы адресации.

\paragraph{Умножение и деление}

Умножение беззнаковых чисел представлено командой MUL.
\begin{minted}{asm}
    MUL OP2; (OP)*(AL) or (AX) or (EAX) -> AX or DX:AX or EDX:EAX
\end{minted}

Умножение знаковых чисел определяется аналогичным образом, но с помощью команды IMUL.



